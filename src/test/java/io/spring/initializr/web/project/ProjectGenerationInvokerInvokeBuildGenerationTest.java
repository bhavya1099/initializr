/*
 * Copyright 2012-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=invokeBuildGeneration_5bd7613099
ROOST_METHOD_SIG_HASH=invokeBuildGeneration_078c4c9bac

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/java-report-test/d854f7fc-c571-4395-a8d5-7c882b49aed8/source/initializr/initializr-web/src/test/java/io/spring/initializr/web/project/ProjectGenerationInvokerTests.java
Tests:
    "@Test
@Test
void invokeBuildGenerationForMavenBuild() {
    WebProjectRequest request = new WebProjectRequest();
    request.setType("maven-project");
    request.initialize(metadata);
    byte[] bytes = this.invoker.invokeBuildGeneration(request);
    String content = new String(bytes);
    new MavenBuildAssert(content).hasGroupId(request.getGroupId()).hasArtifactId(request.getArtifactId()).hasVersion(request.getVersion()).doesNotHaveNode("/project/packaging").hasName(request.getName()).hasDescription(request.getDescription()).hasProperty("java.version", request.getJavaVersion()).hasParent("org.springframework.boot", "spring-boot-starter-parent", request.getBootVersion());
    verifyProjectSuccessfulEventFor(request);
}
"
    "@Test
@Test
void invokeBuildGenerationForGradleBuild() {
    WebProjectRequest request = new WebProjectRequest();
    request.initialize(metadata);
    request.setType("gradle-project");
    request.setJavaVersion("17");
    byte[] bytes = this.invoker.invokeBuildGeneration(request);
    String content = new String(bytes);
    new GroovyDslGradleBuildAssert(content).hasVersion(request.getVersion()).hasPlugin("org.springframework.boot", request.getBootVersion()).hasToolchainForJava("17");
    verifyProjectSuccessfulEventFor(request);
}
"
    "@Test
@Test
void invokeBuildGenerationFailureShouldPublishFailureEvent() {
    WebProjectRequest request = new WebProjectRequest();
    request.initialize(metadata);
    request.setType("foo-bar");
    try {
        this.invoker.invokeBuildGeneration(request);
    } catch (Exception ex) {
        verifyProjectFailedEventFor(request, ex);
    }
}
""""
  Scenario 1: Testing successful execution of invokeBuildGeneration method.

  Details:
    TestName: testSuccessfulExecutionOfInvokeBuildGeneration.
    Description: This test checks if the invokeBuildGeneration method executes successfully without throwing any exception for a valid input request.

  Execution:
    Arrange: Mock the request and provide necessary setup for ProjectDescription and InitializrMetadata.
    Act: Call the invokeBuildGeneration method with the mocked request.
    Assert: Make an assertion to check if the byte array returned is non-null and has appropriate content related to the mocked request.
  Validation:
    The aim is to verify whether there is any problem with handling a standard input request and returning the generated byte array. The test is significant as it checks the correct working of invokeBuildGeneration.

  """

  """
  Scenario 2: Testing exception handling when ProjectGenerationException exception is thrown.

  Details:
    TestName: testHandlingOfProjectGenerationException.
    Description: This test checks if the invokeBuildGeneration method is handling the thrown ProjectGenerationException properly and publishing an error event.

  Execution:
    Arrange: Mock the request and setup for ProjectDescription such that it causes an exception during project generation.
    Act: Call the invokeBuildGeneration method with the mocked request.
    Assert: Assert that an exception is thrown, and also verify that publishProjectFailedEvent method is being called with the correct arguments.
  Validation:
    The aim is to verify whether the method is able to handle exceptions and publishing an event in case of errors. This test is vital as it ensures that software reacts gracefully to unexpected exceptions.

  """

  """
  Scenario 3: Testing the method's behavior with invalid input request type.

  Details:
    TestName: testInvokeBuildGenerationWithInvalidRequestType.
    Description: This test validates if the expected exception is thrown when an invalid request type is provided to the method invokeBuildGeneration.

  Execution:
    Arrange: Set up a request with invalid project type information.
    Act: Invoke invokeBuildGeneration method.
    Assert: Assert that an IllegalArgumentException is thrown.
  Validation:
    This scenario checks the robustness of the method for incorrect user input. It's significant to ensure that method only accepts defined request types, and incorrectly defined project types are rejected.

  """

  """
  Scenario 4: Testing null input request to invokeBuildGeneration.

  Details:
    TestName: testNullInputRequestToInvokeBuildGeneration.
    Description: This test checks how the invokeBuildGeneration method responds when a null input is passed.

  Execution:
    Arrange: Set the input request to null
    Act: Call the invokeBuildGeneration method.
    Assert: Assert that a NullPointerException is thrown.
  Validation:
    This scenario checks the method's behavior when null input is passed. It's important because it should not allow null values, and appropriate exception should be thrown in that case.

  """
*/

// ********RoostGPT********

package io.spring.initializr.web.project;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.mockito.Mockito;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.verify;
import org.junit.jupiter.api.*;
import java.io.IOException;
import java.io.StringWriter;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import io.spring.initializr.generator.buildsystem.BuildItemResolver;
import io.spring.initializr.generator.buildsystem.BuildWriter;
import io.spring.initializr.generator.project.DefaultProjectAssetGenerator;
import io.spring.initializr.generator.project.ProjectAssetGenerator;
import io.spring.initializr.generator.project.ProjectDescription;
import io.spring.initializr.generator.project.ProjectGenerationContext;
import io.spring.initializr.generator.project.ProjectGenerationException;
import io.spring.initializr.generator.project.ProjectGenerator;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import io.spring.initializr.metadata.support.MetadataBuildItemResolver;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.util.FileSystemUtils;

class ProjectGenerationInvokerInvokeBuildGenerationTest {

	@Test
	@Tag("valid")
	public void testSuccessfulExecutionOfInvokeBuildGeneration() {
		// Arrange
		ProjectRequest request = Mockito.mock(ProjectRequest.class);
		InitializrMetadata metadata = Mockito.mock(InitializrMetadata.class);
		ProjectDescription description = Mockito.mock(ProjectDescription.class);
		ProjectGenerator<byte[]> projectGenerator = Mockito.mock(ProjectGenerator.class);
		byte[] expected = new byte[] { 0, 1, 2, 3, 4, 5 };
		Mockito.when(projectGenerator.generate(description, null)).thenReturn(expected);

		ProjectGenerationInvoker invoker = new ProjectGenerationInvoker(null, null,
				new DefaultProjectRequestToDescriptionConverter());

		// Act
		byte[] result = invoker.invokeBuildGeneration(request);

		// Assert
		assertThat(result).isNotNull();
		assertThat(result).isEqualTo(expected);
	}

	@Test
	@Tag("valid")
	public void testHandlingOfProjectGenerationException() {
		// Arrange
		ProjectRequest request = Mockito.mock(ProjectRequest.class);
		InitializrMetadata metadata = Mockito.mock(InitializrMetadata.class);

		ProjectGenerationInvoker invoker = Mockito
			.spy(new ProjectGenerationInvoker(null, null, new DefaultProjectRequestToDescriptionConverter()));
		Mockito.doThrow(new ProjectGenerationException(new NullPointerException()))
			.when(invoker)
			.invokeBuildGeneration(request);

		// Act & Assert
		assertThrows(ProjectGenerationException.class, () -> {
			invoker.invokeBuildGeneration(request);
		});
		verify(invoker).publishProjectFailedEvent(request, metadata,
				new ProjectGenerationException(new NullPointerException()));
	}

	@Test
	@Tag("invalid")
	public void testInvokeBuildGenerationWithInvalidRequestType() {
		// Arrange
		InvalidProjectRequest request = new InvalidProjectRequest();
		InitializrMetadata metadata = Mockito.mock(InitializrMetadata.class);
		DefaultProjectRequestToDescriptionConverter converter = new DefaultProjectRequestToDescriptionConverter();

		ProjectGenerationInvoker invoker = new ProjectGenerationInvoker(null, null, converter);
		// Act & Assert
		assertThrows(IllegalArgumentException.class, () -> {
			invoker.invokeBuildGeneration(request);
		});
	}

	@Test
	@Tag("invalid")
	public void testNullInputRequestToInvokeBuildGeneration() {
		// Arrange
		ProjectGenerationInvoker invoker = new ProjectGenerationInvoker(null, null,
				new DefaultProjectRequestToDescriptionConverter());

		// Act & Assert
		assertThrows(NullPointerException.class, () -> {
			invoker.invokeBuildGeneration(null);
		});
	}

}