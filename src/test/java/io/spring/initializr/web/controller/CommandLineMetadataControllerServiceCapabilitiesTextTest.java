/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=serviceCapabilitiesText_dfb5702f29
ROOST_METHOD_SIG_HASH=serviceCapabilitiesText_33f658da89

"""
Scenario 1: Test serviceCapabilitiesText without any user-agent header
Details:
  TestName: testServiceCapabilitiesWithoutUserAgent
  Description: This test is designed to validate the functionality of the serviceCapabilitiesText method when it is invoked without any user-agent in the header.
Execution:
  Arrange: No user-agent header will be mocked.
  Act: Invoke the serviceCapabilitiesText method with null value for userAgent.
  Assert: Verify that the ResponseEntity in the result contains the content generated by generateGenericCapabilities in its body.
Validation: The test ensures that the serviceCapabilitiesText method can handle requests without a user-agent header, falling back to a generic approach when no specific user-agent is provided. This is important to support clients that may not provide a user-agent.

Scenario 2: Test serviceCapabilitiesText with an unsupported user-agent header
Details:
  TestName: testServiceCapabilitiesWithUnsupportedUserAgent
  Description: This test aims to verify the functionality of serviceCapabilitiesText method when an unsupported user-agent is provided in the header.
Execution:
  Arrange: Mock an unsupported user-agent header.
  Act: Invoke the serviceCapabilitiesText method with the mocked userAgent.
  Assert: Verify that the ResponseEntity in the result contains the content generated by generateGenericCapabilities in its body.
Validation: The test asserts that when the method is called with an unsupported user-agent, it defaults to generateGenericCapabilities, ensuring that unsupported clients receive some response.

Scenario 3: Test serviceCapabilitiesText with user-agent CURL
Details:
  TestName: testServiceCapabilitiesWithCurlUserAgent
  Description: This test is designed to validate the functionality of the serviceCapabilitiesText method when it's invoked with CURL as user-agent in the header.
Execution:
  Arrange: Mock CURL as user-agent header.
  Act: Invoke the serviceCapabilitiesText method with the mocked userAgent.
  Assert: Verify that the ResponseEntity in the result contains the content generated by generateCurlCapabilities in its body.
Validation: The test verifies that the serviceCapabilitiesText method can handle requests from CURL clients and responds with an appropriate content.

Scenario 4: Test serviceCapabilitiesText with user-agent HTTPIE
Details:
  TestName: testServiceCapabilitiesWithHttpieUserAgent
  Description: This test aims to check the functionality of the serviceCapabilitiesText method when it's invoked with HTTPIE as user-agent in the header.
Execution:
  Arrange: Mock HTTPIE as user-agent header.
  Act: Invoke the serviceCapabilitiesText method with the mocked userAgent.
  Assert: Verify that the ResponseEntity in the result contains the content generated by generateHttpieCapabilities in its body.
Validation: The test ensures that the serviceCapabilitiesText method recognizes requests from HTTPIE clients and provides an appropriate response.

Scenario 5: Test serviceCapabilitiesText with user-agent SPRING_BOOT_CLI
Details:
  TestName: testServiceCapabilitiesWithSpringBootCliUserAgent
  Description: This test aims to validate the functionality of serviceCapabilitiesText when invoked with SPRING_BOOT_CLI as user-agent in the header.
Execution:
  Arrange: Mock SPRING_BOOT_CLI as user-agent header.
  Act: Invoke the serviceCapabilitiesText method with the mocked userAgent.
  Assert: Verify that the ResponseEntity in the result contains the content generated by generateSpringBootCliCapabilities in its body.
Validation: The test verifies that the serviceCapabilitiesText method can handle requests from SPRING_BOOT_CLI clients and responds with an appropriate content.
"""
*/

// ********RoostGPT********

package io.spring.initializr.web.controller;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import java.io.IOException;
import org.springframework.http.ResponseEntity;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import io.spring.initializr.generator.io.template.TemplateRenderer;
import org.springframework.http.HttpHeaders;
import io.spring.initializr.web.support.Agent;
import io.spring.initializr.web.support.Agent.AgentId;
import org.junit.jupiter.api.*;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.web.support.CommandLineHelpGenerator;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity.BodyBuilder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

public class CommandLineMetadataControllerServiceCapabilitiesTextTest {

	@Test
	@Tag("valid")
	public void testServiceCapabilitiesWithoutUserAgent() throws IOException {
		String appUrl = "http://localhost:8080";
		String genericContent = "Generic Content";
		CommandLineHelpGenerator mockGenerator = mock(CommandLineHelpGenerator.class);
		when(mockGenerator.generateGenericCapabilities(any(), eq(appUrl))).thenReturn(genericContent);
		TemplateRenderer mockRenderer = mock(TemplateRenderer.class);
		InitializrMetadataProvider mockProvider = mock(InitializrMetadataProvider.class);
		CommandLineMetadataController controller = new CommandLineMetadataController(mockProvider, mockRenderer);
		controller.commandLineHelpGenerator = mockGenerator;
		ResponseEntity<String> result = controller.serviceCapabilitiesText(null);

		assertEquals(genericContent, result.getBody());
	}

	@Test
	@Tag("invalid")
	public void testServiceCapabilitiesWithUnsupportedUserAgent() throws IOException {
		String appUrl = "http://localhost:8080";
		String userAgent = "unsupported";
		String genericContent = "Generic Content";
		CommandLineHelpGenerator mockGenerator = mock(CommandLineHelpGenerator.class);
		when(mockGenerator.generateGenericCapabilities(any(), eq(appUrl))).thenReturn(genericContent);
		TemplateRenderer mockRenderer = mock(TemplateRenderer.class);
		InitializrMetadataProvider mockProvider = mock(InitializrMetadataProvider.class);
		CommandLineMetadataController controller = new CommandLineMetadataController(mockProvider, mockRenderer);
		controller.commandLineHelpGenerator = mockGenerator;
		ResponseEntity<String> result = controller.serviceCapabilitiesText(userAgent);

		assertEquals(genericContent, result.getBody());
	}

	@Test
	@Tag("valid")
	public void testServiceCapabilitiesWithCurlUserAgent() throws IOException {
		String appUrl = "http://localhost:8080";
		String userAgent = "curl";
		String curlContent = "cURL Content";
		CommandLineHelpGenerator mockGenerator = mock(CommandLineHelpGenerator.class);
		when(mockGenerator.generateGenericCapabilities(any(), eq(appUrl))).thenReturn(curlContent);
		TemplateRenderer mockRenderer = mock(TemplateRenderer.class);
		InitializrMetadataProvider mockProvider = mock(InitializrMetadataProvider.class);
		CommandLineMetadataController controller = new CommandLineMetadataController(mockProvider, mockRenderer);
		controller.commandLineHelpGenerator = mockGenerator;
		ResponseEntity<String> result = controller.serviceCapabilitiesText(userAgent);

		assertEquals(curlContent, result.getBody());
	}

	@Test
	@Tag("valid")
	public void testServiceCapabilitiesWithHttpieUserAgent() throws IOException {
		String appUrl = "http://localhost:8080";
		String userAgent = "httpie";
		String httpieContent = "HTTPie Content";
		CommandLineHelpGenerator mockGenerator = mock(CommandLineHelpGenerator.class);
		when(mockGenerator.generateGenericCapabilities(any(), eq(appUrl))).thenReturn(httpieContent);
		TemplateRenderer mockRenderer = mock(TemplateRenderer.class);
		InitializrMetadataProvider mockProvider = mock(InitializrMetadataProvider.class);
		CommandLineMetadataController controller = new CommandLineMetadataController(mockProvider, mockRenderer);
		controller.commandLineHelpGenerator = mockGenerator;
		ResponseEntity<String> result = controller.serviceCapabilitiesText(userAgent);

		assertEquals(httpieContent, result.getBody());
	}

	@Test
	@Tag("valid")
	public void testServiceCapabilitiesWithSpringBootCliUserAgent() throws IOException {
		String appUrl = "http://localhost:8080";
		String userAgent = "spring-boot-cli";
		String springBootCliContent = "Spring Boot CLI Content";
		CommandLineHelpGenerator mockGenerator = mock(CommandLineHelpGenerator.class);
		when(mockGenerator.generateGenericCapabilities(any(), eq(appUrl))).thenReturn(springBootCliContent);
		TemplateRenderer mockRenderer = mock(TemplateRenderer.class);
		InitializrMetadataProvider mockProvider = mock(InitializrMetadataProvider.class);
		CommandLineMetadataController controller = new CommandLineMetadataController(mockProvider, mockRenderer);
		controller.commandLineHelpGenerator = mockGenerator;
		ResponseEntity<String> result = controller.serviceCapabilitiesText(userAgent);

		assertEquals(springBootCliContent, result.getBody());
	}

}