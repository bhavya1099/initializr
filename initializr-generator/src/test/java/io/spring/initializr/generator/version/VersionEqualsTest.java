/*
 * Copyright 2012-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=equals_8224fef9d7
ROOST_METHOD_SIG_HASH=equals_f4eca31364

Scenario 1: Validating object equality with same object instance

Details:
  TestName: equalsWithSameObjectInstance
  Description: The test is meant to check if the equals method returns true when the object instance passed to it is the same as the current one.
Execution:
  Arrange: Create an instance of the Version class.
  Act: Pass that same instance to the equals method of the Version instance.
  Assert: Assert that the method returns true.
Validation:
  The method is supposed to consider an object as equal to itself. The assertion thus verifies this behaviour.

Scenario 2: Validating object equality with null parameter

Details:
  TestName: equalsWithNull
  Description: The test is meant to check if the equals method returns false when the object instance passed to it is null.
Execution:
  Arrange: Create an instance of the Version class.
  Act: Pass null to the equals method of the Version instance.
  Assert: Assert that the method returns false.
Validation:
  The method is supposed to consider any null object as not equal. The assertion thus verifies this behaviour.

Scenario 3: Validating object equality with different class object

Details:
  TestName: equalsWithDifferentClassObject
  Description: The test is meant to check if the equals method returns false when the object is an instance of a class other than Version.
Execution:
  Arrange: Create an instance of the Version class and a different class.
  Act: Pass the different class instance to the equals method of the Version instance.
  Assert: Assert that the method returns false.
Validation:
  The method is designed to consider objects of different classes as not equal. The assertion checks this condition.

Scenario 4: Validating object equality with same class but different data

Details:
  TestName: equalsWithSameClassButDifferentData
  Description: The test is meant to check if the equals method returns false when the Version instances have different major, minor, patch, or qualifier values.
Execution:
  Arrange: Create two instances of the Version class with differing data.
  Act: Pass one instance to the equals method of the other instance.
  Assert: Assert that the method returns false.
Validation:
  The method evaluates equality based on the encapsulated data, so when the data differs, the objects are not considered equal.

Scenario 5: Validating object equality with same class and same data

Details:
  TestName: equalsWithSameClassAndSameData
  Description: The test is meant to check if the equals method returns true when both Version instances have the same major, minor, patch, and qualifier values.
Execution:
  Arrange: Create two instances of the Version class with the same data.
  Act: Pass one instance to the equals method of the other instance.
  Assert: Assert that the method returns true.
Validation:
  The method evaluates equality based on the encapsulated data. When identical data is maintained, the objects are considered to be equal.,
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.*;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.function.Function;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

public class VersionEqualsTest {

	@Test
	@Tag("valid")
	public void equalsWithSameObjectInstance() {
		Version version = new Version(1, 0, 0, null);
		Assertions.assertTrue(version.equals(version));
	}

	@Test
	@Tag("invalid")
	public void equalsWithNull() {
		Version version = new Version(1, 0, 0, null);
		Assertions.assertFalse(version.equals(null));
	}

	@Test
	@Tag("invalid")
	public void equalsWithDifferentClassObject() {
		Version version = new Version(1, 0, 0, null);
		Assertions.assertFalse(version.equals("Not a Version Object"));
	}

	@Test
	@Tag("boundary")
	public void equalsWithSameClassButDifferentData() {
		Version version1 = new Version(1, 0, 0, null);
		Version version2 = new Version(2, 0, 0, null);
		Assertions.assertFalse(version1.equals(version2));
	}

	@Test
	@Tag("valid")
	public void equalsWithSameClassAndSameData() {
		Version version1 = new Version(1, 0, 0, null);
		Version version2 = new Version(1, 0, 0, null);
		Assertions.assertTrue(version1.equals(version2));
	}

}