/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=serviceCapabilitiesV22_76bdf67242
ROOST_METHOD_SIG_HASH=serviceCapabilitiesV22_76bdf67242

"""
Scenario 1: Try Accessing serviceCapabilitiesV22 Request without any restriction.

Details:
  TestName: testGettingServiceCapabilitiesV22WithoutRestriction.
  Description: The test is to ensure that the serviceCapabilitiesV22 method responds with the appropriate ResponseEntity when called without any issues.
Execution:
  Arrange: Mock the dependencies For InitializrMetadataVersion.V2_2 which are needed for the method execution.
  Act: Invoke the serviceCapabilitiesV22 method.
  Assert: Compare the returned ResponseEntity with the expected result.
Validation:
  If everything runs smoothly without causing any trouble, a ResponseEntity is expected. Why? Because that's what the serviceCapabilitiesV22 method does. This test checks if the method duly functions when all conditions are met.

Scenario 2: Run serviceCapabilitiesV22 method where MediaType does not match the requested URL.

Details:
  TestName: testGettingServiceCapabilitiesV22WithMismatchingMediaType.
  Description: This test is meant to check if serviceCapabilitiesV22 method performs validation for the MediaType and returns the appropriate ResponseEntity upon URL request.
Execution:
  Arrange: Create a mock for metadataVersion and set MediaType to a type that will not match with the requesting URL.
  Act: Invoke the serviceCapabilitiesV22 method.
  Assert: Compare the returned ResponseEntity with the expected ResponseEntity which should match error HTTP status as the MediaType doesn't match the URL request.
Validation:
  This test verifies whether the method appropriately handles the case where the MediaType does not match the requested URL. This helps to maintain clean endpoints and ensures the validation check in the method is working as intended.

Scenario 3: Running serviceCapabilitiesV22 method when serviceCapabilitiesFor gave error.

Details:
  TestName: testGettingServiceCapabilitiesV22WithServiceCapabilitiesForFailure.
  Description: This test is to ensure that when dependenciesFor throws an error, serviceCapabilitiesV22 method should do the error handling and return the appropriate ResponseEntity.
Execution:
  Arrange: Mock dependenciesFor to throw an Exception when invoked.
  Act: Invoke the serviceCapabilitiesV22 method.
  Assert: Compare the returned ResponseEntity with the expected ResponseEntity which should match error HTTP status as an exception is thrown during execution.
Validation:
  The serviceCapabilitiesV22 method should be able to handle any exception thrown by dependenciesFor while preparing for the response. So, this test checks whether the error handling part of this method is working as expected.

Note: You could create more test scenarios by considering other potential corner cases, exceptions or different data inputs if more details about the method are provided.
*/

// ********RoostGPT********

package io.spring.initializr.web.controller;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.ResponseEntity;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import java.io.IOException;
import java.util.concurrent.TimeUnit;
import io.spring.initializr.generator.version.Version;
import io.spring.initializr.metadata.DependencyMetadata;
import io.spring.initializr.metadata.DependencyMetadataProvider;
import io.spring.initializr.metadata.InitializrConfiguration.Platform;
import io.spring.initializr.metadata.InvalidInitializrMetadataException;
import io.spring.initializr.web.mapper.DependencyMetadataJsonMapper;
import io.spring.initializr.web.mapper.DependencyMetadataV21JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataJsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV21JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV22JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV2JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataVersion;
import io.spring.initializr.web.project.InvalidProjectRequestException;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.CacheControl;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@ExtendWith(MockitoExtension.class)
public class ProjectMetadataControllerServiceCapabilitiesV22Test {

	@Mock
	InitializrMetadataProvider metadataProviderMock;

	@InjectMocks
	ProjectMetadataController controller;

	@BeforeEach
	void setMockOutput() {
		when(metadataProviderMock.get()).thenReturn(new InitializrMetadata());
	}

	@Test
	@Tag("valid")
	public void testGettingServiceCapabilitiesV22WithoutRestriction() {
		ResponseEntity<String> response = controller.serviceCapabilitiesV22();
		assertNotNull(response);
		assertTrue(response.getStatusCode().is2xxSuccessful());
	}

	@Test
	@Tag("invalid")
	public void testGettingServiceCapabilitiesV22WithMismatchingMediaType() {
		when(metadataProviderMock.get()).thenThrow(InvalidProjectRequestException.class);
		assertThrows(InvalidProjectRequestException.class, () -> controller.serviceCapabilitiesV22());
	}

	@Test
	@Tag("invalid")
	public void testGettingServiceCapabilitiesV22WithServiceCapabilitiesForFailure() {
		when(controller.serviceCapabilitiesFor(InitializrMetadataVersion.V2_2))
			.thenThrow(UnsupportedOperationException.class);
		assertThrows(UnsupportedOperationException.class, () -> controller.serviceCapabilitiesV22());
	}

}