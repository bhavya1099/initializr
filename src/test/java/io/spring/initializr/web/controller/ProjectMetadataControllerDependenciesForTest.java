/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=dependenciesFor_bfb710c364
ROOST_METHOD_SIG_HASH=dependenciesFor_b87841a204

"""
Scenario 1: Test valid Spring Boot version.
Details:
  TestName: testValidBootVersion
  Description: This test verify when a valid Spring Boot version is provided.
Execution:
  Arrange: Mock the metadataProvider to return a valid InitializrMetadata. Also, define a valid spring boot version.
  Act: Invoke dependenciesFor method with the InitializrMetadataVersion and the valid Spring Boot version.
  Assert: Check if the ResponseEntity returned has a body, media type, Etag, and CacheControl.
Validation:
  The assertion validates that for a valid Spring Boot version, the method returns a valid ResponseEntity with necessary details. This signifies that the application can manage valid requests correctly.


Scenario 2: Test incompatible Spring Boot version.
Details:
  TestName: testIncompatibleBootVersion
  Description: This test aim to verify the method's behavior when an incompatible version of Spring Boot is provided.
Execution:
  Arrange: Mock the metadataProvider to return a valid InitializrMetadata. Also, define an incompatible spring boot version.
  Act: Invoke dependenciesFor method with the InitializrMetadataVersion and the incompatible Spring Boot version.
  Assert: Check for the existence of an InvalidProjectRequestException.
Validation:
  The assertion confirms that for an incompatible Spring Boot version, the method throws an InvalidProjectRequestException. This test is crucial for examining how the application handles incompatible requests.

Scenario 3: Test Null Spring Boot version.
Details:
  TestName: testNullBootVersion
  Description: This test is to check the method's functionality when no Boot version is provided, i.e., null is passed to the method.
Execution:
  Arrange: Mock the metadataProvider to return a valid InitializrMetadata.
  Act: Invoke dependenciesFor method with the InitializrMetadataVersion and a null Spring Boot version.
  Assert: Check if the ResponseEntity returned has a body, media type, Etag, and CacheControl.
Validation:
  The assertion verifies that when no spring boot version is provided, the method returns a ResponseEntity by using the default spring boot version.

Scenario 4: Test valid Spring Boot version but DependencyMetadataProvider returns null.
Details:
  TestName: testDependencyMetadataProviderReturnsNull
  Description: This test verifies the method's behavior when the DependencyMetadataProvider returns null for a valid Spring Boot version.
Execution:
  Arrange: Mock the metadataProvider to return a valid InitializrMetadata. Mock the dependencyMetadataProvider to return null. Define a valid spring boot version.
  Act: Invoke dependenciesFor method with the InitializrMetadataVersion and the valid Spring Boot version.
  Assert: Validate that the body of the ResponseEntity is also null.
Validation:
  This assertion proves that if the DependencyMetadataProvider can't provide DependencyMetadata for any reason (even for a valid request), the method still handles it gracefully, returning null as part of the ResponseEntity.
  """
*/

// ********RoostGPT********

package io.spring.initializr.web.controller;

import io.spring.initializr.generator.version.Version;
import io.spring.initializr.metadata.DependencyMetadataProvider;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import io.spring.initializr.metadata.InvalidInitializrMetadataException;
import io.spring.initializr.web.project.InvalidProjectRequestException;
import io.spring.initializr.web.mapper.DependencyMetadataJsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataJsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV21JsonMapper;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockHttpServletResponse;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.*;
import java.io.IOException;
import java.util.concurrent.TimeUnit;
import io.spring.initializr.metadata.DependencyMetadata;
import io.spring.initializr.metadata.InitializrConfiguration.Platform;
import io.spring.initializr.web.mapper.DependencyMetadataV21JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV22JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV2JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataVersion;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.CacheControl;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@ExtendWith(MockitoExtension.class)
class ProjectMetadataControllerDependenciesForTest {

	@Mock
	private InitializrMetadataProvider metadataProvider;

	@Mock
	private DependencyMetadataProvider dependencyMetadataProvider;

	@Mock
	private InitializrMetadata metadata;

	private ProjectMetadataController controller = new ProjectMetadataController(metadataProvider,
			dependencyMetadataProvider);

	@Test
	@Tag("valid")
	void testValidBootVersion() throws Exception {
		when(metadataProvider.get()).thenReturn(metadata);
		var version = "2.4.5";

		ResponseEntity<String> response = controller.dependenciesFor(InitializrMetadataVersion.V2_2, version);

		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getHeaders());
		assertNotNull(response.getBody());

	}

	@Test
	@Tag("valid")
	void testIncompatibleBootVersion() {
		when(metadataProvider.get()).thenReturn(metadata);
		var version = "1.0.0";
		assertThrows(InvalidProjectRequestException.class,
				() -> controller.dependenciesFor(InitializrMetadataVersion.V2_2, version));

	}

	@Test
	@Tag("valid")
	void testNullBootVersion() {
		when(metadataProvider.get()).thenReturn(metadata);

		ResponseEntity<String> response = controller.dependenciesFor(InitializrMetadataVersion.V2_2, null);

		assertNotNull(response.getBody());
		assertEquals(HttpStatus.OK, response.getStatusCode());
	}

	@Test
	@Tag("valid")
	void testDependencyMetadataProviderReturnsNull() {
		when(metadataProvider.get()).thenReturn(metadata);
		when(dependencyMetadataProvider.get(any(), any())).thenReturn(null);
		var version = "1.4.5";

		ResponseEntity<String> response = controller.dependenciesFor(InitializrMetadataVersion.V2_2, version);

		assertNull(response.getBody());
	}

}