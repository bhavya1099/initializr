/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=dependenciesV22_5591217b85
ROOST_METHOD_SIG_HASH=dependenciesV22_2abc1e8737

"""
Scenario 1: Fetch dependencies with valid boot version

TestName: fetchDependenciesWithValidBootVersion
Description: Test to check if dependencies fetch properly when a valid spring boot version is provided.
Execution:
  Arrange: Create a valid spring boot version as input.
  Act: On invocation of dependenciesV22 with the valid boot version.
  Assert: Assert the ResponseEntity received, checking for HttpStatus.OK and check if the body contains the expected dependencies' data.
Validation:
  This asserts that the expected dependencies' data is retrieved and the HTTP status is OK when a valid boot version is provided. This helps in ensuring that the boot version is supported and the dependencies data retrieval process is working correctly.

Scenario 2: Fetch dependencies with invalid boot version

TestName: fetchDependenciesWithInvalidBootVersion
Description: Test to check the system's response when an invalid spring boot version is provided.
Execution:
  Arrange: Create an invalid spring boot version as input.
  Act: On invocation of dependenciesV22 with the invalid boot version.
  Assert: Assert the ResponseEntity received, checking for HttpStatus.BAD_REQUEST or an exception being thrown.
Validation:
  This asserts that the system correctly recognizes the boot version as invalid and handles it appropriately by returning BAD_REQUEST status or throwing an exception. This checks the system's ability to handle invalid inputs and prevents possible system crashes from such situations.

Scenario 3: Fetch dependencies without boot version

TestName: fetchDependenciesWithoutBootVersion
Description: Test to check the system's response when no boot version is provided.
Execution:
  Arrange: Do not use boot version as input.
  Act: On invocation of dependenciesV22.
  Assert: Assert the ResponseEntity received, checking for HttpStatus.OK and check if the body contains the expected dependencies' data of the default boot version.
Validation:
  This test asserts that the system correctly retrieves dependencies of default boot version when no boot version is provided. This guarantees that the system can handle cases where the boot version is not specified.
"""
*/

// ********RoostGPT********

package io.spring.initializr.web.controller;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.mockito.Mockito;
import org.springframework.http.ResponseEntity;
import io.spring.initializr.metadata.DependencyMetadataProvider;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.generator.version.Version;
import io.spring.initializr.web.project.InvalidProjectRequestException;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import java.io.IOException;
import java.util.concurrent.TimeUnit;
import io.spring.initializr.metadata.DependencyMetadata;
import io.spring.initializr.metadata.InitializrConfiguration.Platform;
import io.spring.initializr.metadata.InvalidInitializrMetadataException;
import io.spring.initializr.web.mapper.DependencyMetadataJsonMapper;
import io.spring.initializr.web.mapper.DependencyMetadataV21JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataJsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV21JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV22JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV2JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataVersion;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.CacheControl;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

public class ProjectMetadataControllerDependenciesV22Test {

	private ProjectMetadataController projectMetadataController;

	private InitializrMetadataProvider metadataProvider = Mockito.mock(InitializrMetadataProvider.class);

	private DependencyMetadataProvider dependencyMetadataProvider = Mockito.mock(DependencyMetadataProvider.class);

	@BeforeEach
	public void setup() {
		projectMetadataController = new ProjectMetadataController(metadataProvider, dependencyMetadataProvider);
	}

	@Test
	@Tag("valid")
	public void fetchDependenciesWithValidBootVersion() {
		// Arrange
		String bootVersion = "2.3.2";
		InitializrMetadata metadata = new InitializrMetadata();
		Version version = Version.parse(bootVersion);
		when(metadataProvider.get()).thenReturn(metadata);
		when(metadata.getBootVersions().getDefault().getId()).thenReturn(bootVersion);
		// Act
		ResponseEntity<String> response = projectMetadataController.dependenciesV22(bootVersion);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertTrue(response.getBody().contains(bootVersion));
	}

	@Test
	@Tag("invalid")
	public void fetchDependenciesWithInvalidBootVersion() {
		// Arrange
		String bootVersion = "5.5.5";
		when(metadataProvider.get()).thenThrow(new InvalidProjectRequestException());
		// Act & Assert
		assertThrows(InvalidProjectRequestException.class,
				() -> projectMetadataController.dependenciesV22(bootVersion));
	}

	@Test
	@Tag("boundary")
	public void fetchDependenciesWithoutBootVersion() {
		// Arrange
		String defaultBootVersion = "2.1.2";
		InitializrMetadata metadata = new InitializrMetadata();
		when(metadataProvider.get()).thenReturn(metadata);
		when(metadata.getBootVersions().getDefault().getId()).thenReturn(defaultBootVersion);
		// Act
		ResponseEntity<String> response = projectMetadataController.dependenciesV22(null);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertTrue(response.getBody().contains(defaultBootVersion));
	}

}