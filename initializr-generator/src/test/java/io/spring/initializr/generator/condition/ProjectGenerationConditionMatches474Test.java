/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=matches_6d74fa5a6e
ROOST_METHOD_SIG_HASH=matches_6d74fa5a6e

"""
Scenario 1: Validate scenario where matching method returns true
  Details:
    TestName: matchesMethodReturnsTrue
    Description: This test scenario is meant to check when the matches method returns true by providing a ProjectDescription, ConditionContext and AnnotatedTypeMetadata that satisfy the matching condition.
  Execution:
    Arrange: Initialize ProjectDescription, ConditionContext and AnnotatedTypeMetadata instances with the required data.
    Act: Invoke the matches method using the initialized values.
    Assert: AssertTrue to confirm that the matches method returns true.
  Validation:
    This assertion aims to verify the proper functioning of the matches method. The expected result of returning true is when all provided arguments match with the conditions defined in the matches method.
    This is important to ensure the desired project generation conditions are met.

Scenario 2: Validate scenario where matching method returns false
  Details:
    TestName: matchesMethodReturnsFalse
    Description: This test scenario is meant to check when the matches method returns false by providing a ProjectDescription, ConditionContext and AnnotatedTypeMetadata that does not satisfy the matching condition.
  Execution:
    Arrange: Initialize ProjectDescription, ConditionContext and AnnotatedTypeMetadata instances with data that will not meet the conditions.
    Act: Invoke the matches method using the initialized values.
    Assert: AssertFalse to check if the matches method returns false.
  Validation:
    This assertion aims to confirm that the matches method functions correctly by not matching with the non-satisfactory conditions and returns false. Understanding when the method returns false helps in identifying the conditions that do not meet the project generation requirement.

Scenario 3: Test runtime exceptions if invalid data inserted
  Details:
    TestName: throwsExceptionOnInvalidInput
    Description: This test is intended to check if exceptions are properly thrown when the matches method is handed null or invalid input data.
  Execution:
    Arrange: Provide null or invalid input values to ProjectDescription, ConditionContext and AnnotatedTypeMetadata.
    Act: Invoke the matches method with the null or invalid values.
    Assert: Use JUnit's ExpectedException rule to assert that an exception is thrown.
  Validation:
    Asserting that an exception is thrown verifies the method's error handling capabilities. Proper functioning of exception generations is essential to understand and manage error scenarios, which aids in avoiding system failures.
"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.condition;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import io.spring.initializr.generator.project.ProjectDescription;
import org.springframework.context.annotation.Condition;

public class ProjectGenerationConditionMatches474Test {

	@Mock
	private ProjectDescription projectDescription;

	@Mock
	private ConditionContext conditionContext;

	@Mock
	private AnnotatedTypeMetadata metadata;

	@Test
	@Tag("valid")
	void matchesMethodReturnsTrue() {
		Mockito.when(conditionContext.getBeanFactory().getBean(ProjectDescription.class))
			.thenReturn(projectDescription);
		Mockito.when(ProjectGenerationCondition.matches(projectDescription, conditionContext, metadata))
			.thenReturn(true);

		assertTrue(ProjectGenerationCondition.matches(projectDescription, conditionContext, metadata));
	}

	@Test
	@Tag("invalid")
	void matchesMethodReturnsFalse() {
		Mockito.when(conditionContext.getBeanFactory().getBean(ProjectDescription.class))
			.thenReturn(projectDescription);
		Mockito.when(ProjectGenerationCondition.matches(projectDescription, conditionContext, metadata))
			.thenReturn(false);

		assertFalse(ProjectGenerationCondition.matches(projectDescription, conditionContext, metadata));
	}

	@Test
	@Tag("boundary")
	void throwsExceptionOnInvalidInput() {
		Mockito.when(conditionContext.getBeanFactory().getBean(ProjectDescription.class)).thenReturn(null);

		assertThrows(NullPointerException.class,
				() -> ProjectGenerationCondition.matches(null, conditionContext, metadata));
	}

}