/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=getTimestamp_ec5ce868bc
ROOST_METHOD_SIG_HASH=getTimestamp_21164626b6

"""
Scenario 1: Test to check whether getTimestamp() returns correct timestamp value.

Details:
  TestName: testIfGetTimestampReturnsCorrectValue.
  Description: This test checks whether getTimestamp() method returns the correct timestamp that has been set initially.
Execution:
  Arrange: Set a certain value to the timestamp.
  Act: Invoke getTimestamp() method.
  Assert: Use JUnit assertions to check if the return value from getTimestamp() method equals the value set initially.
Validation:
  This is to validate if the getTimestamp() method retrieves the correct timestamp that was set previously. It is crucial to the function of the ProjectRequestEvent class, which relies on this data.

Scenario 2: Test to check default return value of getTimestamp().

Details:
  TestName: testDefaultReturnValueOfGetTimestamp.
  Description: This test checks whether the getTimestamp() method returns default value (0L), for newly created instance (where no timestamp is set explicitly).
Execution:
  Arrange: Create an instance of ProjectRequestEvent without setting the timestamp.
  Act: Invoke the getTimestamp() method.
  Assert: Use JUnit assertions to confirm if the return value from getTimestamp() method is 0L.
Validation:
  This checks the initialization and default return value of the getTimestamp() method. The result verifies the default state of a newly created ProjectRequestEvent object.

Scenario 3: Test to verify timestamp immutability

Details:
  TestName: testTimestampImmutability.
  Description: This test validates the immutability of the timestamp. As the field is marked as final, it should not change its value once assigned.
Execution:
  Arrange: Create an instance of ProjectRequestEvent and assign a value to timestamp.
  Act: Try changing the timestamp value.
  Assert: Use JUnit assertions to verify if the value of timestamp is the one initially assigned, and has not changed.
Validation:
  This test is meant to assert the immutability of the timestamp instance variable, this helps ensure the integrity of the project request event capture mechanism.

Scenario 4: Test to verify non-nullness of timestamp

Details:
  TestName: testNotNullTimestamp.
  Description: This test validates that the timestamp is non-null.
Execution:
  Arrange: Create an instance of ProjectRequestEvent.
  Act: Call the getTimestamp() method.
  Assert: Use JUnit assertions to verify if the returned value is non-null.
Validation:
  This tests for the non-nullness of the timestamp because the class specification defines it as a primitive type long, it cannot hold null values, instead, it should return the default value - 0L.
"""
*/

// ********RoostGPT********

package io.spring.initializr.web.project;

import org.junit.jupiter.api.*;
import org.mockito.Mockito;
import io.spring.initializr.metadata.InitializrMetadata;

public class ProjectRequestEventGetTimestampTest {

	@Test
	@DisplayName("Test if getTimestamp() returns correct value")
	@Tag("valid")
	public void testIfGetTimestampReturnsCorrectValue() {
		ProjectRequest request = Mockito.mock(ProjectRequest.class);
		InitializrMetadata meta = Mockito.mock(InitializrMetadata.class);
		ProjectRequestEvent event = new ProjectRequestEvent(request, meta);
		long initialTime = event.getTimestamp();

		Assertions.assertEquals(initialTime, event.getTimestamp(),
				"The timestamp returned does not match the expected value.");
	}

	@Test
	@DisplayName("Test default return value of getTimestamp()")
	@Tag("boundary")
	public void testDefaultReturnValueOfGetTimestamp() {
		ProjectRequest request = Mockito.mock(ProjectRequest.class);
		InitializrMetadata meta = Mockito.mock(InitializrMetadata.class);
		ProjectRequestEvent event = new ProjectRequestEvent(request, meta);

		// assuming that the system clock isn't exactly at the epoch (1970-01-01 00:00:00)
		Assertions.assertNotEquals(0L, event.getTimestamp(),
				"The timestamp returned should not be epoch time 0L for a newly created object.");
	}

	@Test
	@DisplayName("Test timestamp immutability")
	@Tag("valid")
	public void testTimestampImmutability() {
		ProjectRequest request = Mockito.mock(ProjectRequest.class);
		InitializrMetadata meta = Mockito.mock(InitializrMetadata.class);
		ProjectRequestEvent event = new ProjectRequestEvent(request, meta);
		long initialTime = event.getTimestamp();
		// wait for sometime
		try {
			Thread.sleep(1000L);
		}
		catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		}

		Assertions.assertEquals(initialTime, event.getTimestamp(),
				"The timestamp returned is not the same as the initial timestamp indicating mutability.");
	}

	@Test
	@DisplayName("Test non-null timestamp")
	@Tag("valid")
	public void testNotNullTimestamp() {
		ProjectRequest request = Mockito.mock(ProjectRequest.class);
		InitializrMetadata meta = Mockito.mock(InitializrMetadata.class);
		ProjectRequestEvent event = new ProjectRequestEvent(request, meta);

		Assertions.assertNotNull(event.getTimestamp(), "The timestamp returned should not be null.");
	}

}