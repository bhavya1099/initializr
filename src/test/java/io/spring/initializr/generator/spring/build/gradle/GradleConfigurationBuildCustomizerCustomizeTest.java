/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=customize_34633c732b
ROOST_METHOD_SIG_HASH=customize_deb7e13fa6

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/java-report-test/1746075742/source/initializr/initializr-generator-spring/src/test/java/io/spring/initializr/generator/spring/build/gradle/GradleConfigurationBuildCustomizerTests.java
Tests:
    "@Test
private void customize(GradleBuild build) {
    new GradleConfigurationBuildCustomizer().customize(build);
}
"

File Path: /var/tmp/Roost/RoostGPT/java-report-test/1746075742/source/initializr/initializr-generator-spring/src/test/java/io/spring/initializr/generator/spring/build/gradle/GradleAnnotationProcessorScopeBuildCustomizerTests.java
Tests:
    "@Test
private void customize(GradleBuild build) {
    new GradleAnnotationProcessorScopeBuildCustomizer().customize(build);
}
"

File Path: /var/tmp/Roost/RoostGPT/java-report-test/1746075742/source/initializr/initializr-web/src/test/java/io/spring/initializr/web/project/MetadataProjectDescriptionCustomizerTests.java
Tests:
    "@Test
MutableProjectDescription customize(MutableProjectDescription description) {
    new MetadataProjectDescriptionCustomizer(this.metadata).customize(description);
    return description;
}
""""
  Scenario 1: Customization within Provided Runtime Dependency and without War Plugin

  Details:
    TestName: testProvidedRuntimeWithNoWarPlugin.
    Description: This test checks the customization of GradleBuild configuration with dependencies within the providedRuntime scope but without the 'war' plugin.
  Execution:
    Arrange: Create a mock GradleBuild object with 'providedRuntime' dependencies and no 'war' plugin.
    Act: Invoke the customize method with the mock GradleBuild object.
    Assert: Verify that the 'providedRuntime' configuration has been added to the GradleBuild object.
  Validation:
    The assertion verifies that the 'providedRuntime' configuration is added when appropriate dependencies are present, and the 'war' plugin is absent. This behavior aligns with the method's logic and certain business rules of the application.

  Scenario 2: Customization with War Plugin

  Details:
    TestName: testCustomizationWithWarPlugin.
    Description: This test checks the customize method when the GradleBuild object contains the 'war' plugin, regardless of its dependencies' scope.
  Execution:
    Arrange: Create a mock GradleBuild object with any dependencies and 'war' plugin.
    Act: Invoke the customize method with the mock GradleBuild object.
    Assert: Verify that no extra configuration is added to the GradleBuild.
  Validation:
    As per the method logic, no extra configuration should be added when a 'war' plugin is present. The test validates the correct execution of this part of the logic.

  Scenario 3: Customization without Provided Runtime Dependency and War Plugin

  Details:
    TestName: testCustomizationWithoutProvidedRuntimeAndWarPlugin.
    Description: This test checks the customize method when the GradleBuild lacks both 'providedRuntime' dependencies and the 'war' plugin.
  Execution:
    Arrange: Create a mock GradleBuild object with any dependencies, excluding 'providedRuntime', and no 'war' plugin.
    Act: Invoke customize with the mock GradleBuild object.
    Assert: Verify that no extra configuration is added.
  Validation:
    The assertion verifies that no configuration is added when neither 'providedRuntime' dependency nor 'war' plugin is present. This scenario checks the method under the most neutral conditions.

  Scenario 4: Customization with Provided Runtime Dependency and War Plugin

  Details:
    TestName: testBothProvidedRuntimeAndWarPlugin.
    Description: This test checks the customize method when 'providedRuntime' dependencies and 'war' plugin is present in GradleBuild.
  Execution:
    Arrange: Create a mock GradleBuild object with 'providedRuntime' dependencies and 'war' plugin.
    Act: Invoke customize with the mock GradleBuild object.
    Assert: Verify that no 'providedRuntime' configuration has been added.
  Validation:
    This test verifies that no 'providedRuntime' configuration has been added when both 'providedRuntime' dependency and 'war' plugin are present. The test is significant as it validates the correct execution of the customize method under all conditions.
"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.spring.build.gradle;

import io.spring.initializr.generator.buildsystem.BuildItemResolver;
import io.spring.initializr.generator.buildsystem.Dependency;
import io.spring.initializr.generator.buildsystem.DependencyContainer;
import io.spring.initializr.generator.buildsystem.DependencyScope;
import io.spring.initializr.generator.buildsystem.gradle.GradleBuild;
import io.spring.initializr.generator.buildsystem.gradle.GradlePlugin;
import io.spring.initializr.generator.buildsystem.gradle.GradlePluginContainer;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import java.util.ArrayList;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import io.spring.initializr.generator.spring.build.BuildCustomizer;
import org.springframework.core.Ordered;

public class GradleConfigurationBuildCustomizerCustomizeTest {

	@Test
	@Tag("valid")
	public void testProvidedRuntimeWithNoWarPlugin() {
		GradleBuild build = mock(GradleBuild.class);
		DependencyContainer dependencyContainer = mock(DependencyContainer.class);
		ArrayList<Dependency> providedRuntimeDependencies = new ArrayList<>();
		providedRuntimeDependencies.add(new Dependency("providedRuntime", DependencyScope.PROVIDED_RUNTIME));
		when(build.dependencies()).thenReturn(dependencyContainer);
		when(dependencyContainer.items()).thenReturn(providedRuntimeDependencies.stream());
		when(build.plugins()).thenReturn(mock(GradlePluginContainer.class));

		new GradleConfigurationBuildCustomizer().customize(build);

		verify(build.configurations(), times(1)).add("providedRuntime");
	}

	@Test
	@Tag("valid")
	public void testCustomizationWithWarPlugin() {
		GradleBuild build = mock(GradleBuild.class);
		when(build.plugins()).thenReturn(new GradlePluginContainer(new BuildItemResolver(null, null, null)));
		build.plugins().add("war");

		new GradleConfigurationBuildCustomizer().customize(build);

		verify(build.configurations(), times(0)).add(anyString());
	}

	@Test
	@Tag("valid")
	public void testCustomizationWithoutProvidedRuntimeAndWarPlugin() {
		GradleBuild build = mock(GradleBuild.class);

		new GradleConfigurationBuildCustomizer().customize(build);

		verify(build.configurations(), times(0)).add(anyString());
	}

	@Test
	@Tag("valid")
	public void testBothProvidedRuntimeAndWarPlugin() {
		GradleBuild build = mock(GradleBuild.class);
		DependencyContainer dependencyContainer = mock(DependencyContainer.class);
		ArrayList<Dependency> providedRuntimeDependencies = new ArrayList<>();
		providedRuntimeDependencies.add(new Dependency("providedRuntime", DependencyScope.PROVIDED_RUNTIME));
		when(build.dependencies()).thenReturn(dependencyContainer);
		when(dependencyContainer.items()).thenReturn(providedRuntimeDependencies.stream());
		when(build.plugins()).thenReturn(new GradlePluginContainer(new BuildItemResolver(null, null, null)));
		build.plugins().add("war");

		new GradleConfigurationBuildCustomizer().customize(build);

		verify(build.configurations(), Mockito.times(0)).add("providedRuntime");
	}

}