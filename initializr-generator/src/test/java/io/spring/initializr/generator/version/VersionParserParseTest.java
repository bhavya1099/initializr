/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=parse_dc4eb9eee9
ROOST_METHOD_SIG_HASH=parse_4420df3761

"""
Scenario 1: Test when the given version string is null

Details:
  TestName: testParseWithNullInput
  Description: This test is meant to check if the parse method handles a null input as expected by asserting a NullPointerException.
Execution:
  Arrange: There is no arrangement needed for this test scenario.
  Act: Invoke the parse method with null as the parameter.
  Assert: Expect a NullPointerException.
Validation:
  The assertion is made on the assumption that the parse method should throw a NullPointerException when input text is null. This is significant to validate if the method handles a null value as expected.

Scenario 2: Test with a valid version string without qualifier

Details:
  TestName: testParseWithValidVersionWithoutQualifier
  Description: Validate the method can correctly parse version string without a qualifier.
Execution:
  Arrange: Create a version string "1.2.3" without qualifier.
  Act: Invoke parse method with the created version string.
  Assert: Expect a Version object with the Major, Minor, and Patch values are equal to 1, 2, and 3 respectively, and the Qualifier is null.
Validation:
  The test verifies that the method can correctly handle and parse a valid version string without a qualifier.

Scenario 3: Test with a valid version string with qualifier

Details:
  TestName: testParseWithValidVersionWithQualifier
  Description: Check whether the parse method can correctly parse version string with a qualifier.
Execution:
  Arrange: Create version string "2.3.4-BETA".
  Act: Invoke parse method with the version string.
  Assert: Assure a Version object with the Major, Minor, and Patch values equal to 2, 3, and 4 respectively, and the Qualifier has id "BETA".
Validation:
  The test checks if the parse method can correctly handle and parse a valid version string with a qualifier.

Scenario 4: Test when the version string doesn't match regex

Details:
  TestName: testParseWithInvalidVersionFormat
  Description: Evaluate the functioning of the parse method with the version string that doesn't match the VERSION_REGEX regex.
Execution:
  Arrange: Initiate a version string "1.2" which doesn't follow the needed major.minor.patch format.
  Act: Invoke parse method with the version string.
  Assert: Expect an InvalidVersionException.
Validation:
  The test decides if the method appropriately throws an InvalidVersionException when the version string doesn't match the VERSION_REGEX regex.

Scenario 5: Test with a version string having "x" as minor and patch

Details:
  TestName: testParseWithXAsMinorAndPatch
  Description: Evaluate if the parse method can handle the version string with 'x' as Minor and Patch version values, signifying any latest version.
Execution:
  Arrange: Prepare version string "1.x.x".
  Act: Invoke parse method with the version string.
  Assert: Check if a Version object is returned with the Major value as 1 and both Minor and Patch set to 999 and Qualifier as null.
Validation:
  The test makes sure if the parse method can correctly respond to a version string with 'x' as Minor and Patch version values.
"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.function.Executable;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import org.junit.jupiter.api.*;
import java.util.Collections;
import java.util.List;
import io.spring.initializr.generator.version.Version.Qualifier;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

public class VersionParserParseTest {

	private VersionParser versionParser;

	private static final Pattern VERSION_REGEX = Pattern
		.compile("^(\\d+)\\.(\\d+)(\\.(\\d+))?(\\-(.*?)(\\.(\\d+))?)?$");

	@BeforeEach
	public void setup() {
		versionParser = new VersionParser(Collections.emptyList());
	}

	@Test
	@Tag("invalid")
	public void testParseWithNullInput() {
		Assertions.assertThrows(NullPointerException.class, new Executable() {
			@Override
			public void execute() throws Throwable {
				versionParser.parse(null);
			}
		});
	}

	@Test
	@Tag("valid")
	public void testParseWithValidVersionWithoutQualifier() {
		String versionString = "1.2.3";
		Matcher matcher = VERSION_REGEX.matcher(versionString);
		matcher.matches();
		Version expectedVersion = new Version(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)),
				Integer.parseInt(matcher.group(3)), null);
		Version actualVersion = versionParser.parse(versionString);
		Assertions.assertEquals(expectedVersion, actualVersion);
	}

	@Test
	@Tag("valid")
	public void testParseWithValidVersionWithQualifier() {
		String versionString = "2.3.4-BETA";
		Matcher matcher = VERSION_REGEX.matcher(versionString);
		matcher.matches();
		Qualifier expectedQualifier = new Qualifier(matcher.group(5), null, null);
		Version expectedVersion = new Version(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)),
				Integer.parseInt(matcher.group(3)), expectedQualifier);
		Version actualVersion = versionParser.parse(versionString);
		Assertions.assertEquals(expectedVersion, actualVersion);
	}

	@Test
	@Tag("invalid")
	public void testParseWithInvalidVersionFormat() {
		Assertions.assertThrows(InvalidVersionException.class, new Executable() {
			@Override
			public void execute() throws Throwable {
				versionParser.parse("1.2");
			}
		});
	}

	@Test
	@Tag("valid")
	public void testParseWithXAsMinorAndPatch() {
		String versionString = "1.x.x";
		Matcher matcher = VERSION_REGEX.matcher(versionString);
		matcher.matches();
		Version expectedVersion = new Version(Integer.parseInt(matcher.group(1)), 999, 999, null);
		Version actualVersion = versionParser.parse(versionString);
		Assertions.assertEquals(expectedVersion, actualVersion);
	}

}