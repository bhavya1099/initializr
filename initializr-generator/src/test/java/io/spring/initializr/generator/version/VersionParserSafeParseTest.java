/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=safeParse_6947c09230
ROOST_METHOD_SIG_HASH=safeParse_4be9e23a71

Scenario 1: Parsing Valid Version String

Details:
  TestName: testParseValidVersionString.
  Description: This test will validate the function when the provided version string falls under the correct pattern of valid syntax (major.minor.patch).
Execution:
  Arrange: Provide a valid version string such as "1.2.3".
  Act: Call safeParse() method by passing this valid version string.
  Assert: Assert the output of the Version class instance should be not null.
Validation:
  The Assertion is checking that a valid version string is correctly parsed and returned as Version class instance without throwing any error. This confirms that the version string adheres to the standard format and is successfully parsed.

Scenario 2: Parsing Invalid Version String

Details:
  TestName: testParseInvalidVersionString.
  Description: This test will validate the function when an invalid version string is provided (That does not adhere to the correct version string pattern).
Execution:
  Arrange: Provide an invalid version string such as "a.b.c".
  Act: Call safeParse() method and pass this invalid version string.
  Assert: Assert that the output of the method should be null.
Validation:
  Asserting null will signify that invalid version strings are identified and handled correctly, i.e. not expected to throw an error, instead provide a null value.

Scenario 3: Parsing Null Version String

Details:
  TestName: testParseNullVersionString.
  Description: This test will validate the function when a null is provided as a version string.
Execution:
  Arrange: Provide null as input.
  Act: Call safeParse() method by passing null.
  Assert: Assert that the output of this method should be null.
Validation:
 Asserting null checks for the input validation and confirms that the function can handle a null input, without causing the system to crash or produce unreliable results.

Scenario 4: Parsing Version String with Wildcards

Details:
  TestName: testParseWildcardVersionString.
  Description: This test will verify the ability of the function to handle version strings with wildcards.
Execution:
  Arrange: Provide a version string with wildcards like "1.x.x".
  Act: Call safeParse() method by passing this wildcard version string.
  Assert: Assert that the output of the method should be not null.
Validation:
  Asserting not null checks if the system can successfully parse version strings that contain wildcards. This verifies the system's ability to deal with dynamic versions.

Scenario 5: Parsing Version String with Qualifier

Details:
  TestName: testParseQualifiedVersionString.
  Description: This test will verify the function's handling of version strings that are appended with a qualifier.
Execution:
  Arrange: Provide a version string with a qualifier like "1.2.3.RELEASE".
  Act: Call safeParse() method by passing this qualified version string.
  Assert: Assert that the output of the method, specifically the qualifier properties, match the expected values.
Validation:
  Assertion verifies that the system correctly parses and retains qualifier information when dealing with qualified version strings.
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.*;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import io.spring.initializr.generator.version.Version.Qualifier;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

public class VersionParserSafeParseTest {

	private VersionParser versionParser = new VersionParser(Collections.emptyList());

	@Test
	@Tag("valid")
	public void testParseValidVersionString() {
		String version = "1.2.3";
		Version output = versionParser.safeParse(version);
		assertNotNull(output);
		assertEquals(1, output.getMajor().intValue());
		assertEquals(2, output.getMinor().intValue());
		assertEquals(3, output.getPatch().intValue());
	}

	@Test
	@Tag("invalid")
	public void testParseInvalidVersionString() {
		String version = "a.b.c";
		Version output = versionParser.safeParse(version);
		assertNull(output);
	}

	@Test
	@Tag("boundary")
	public void testParseNullVersionString() {
		String version = null;
		Version output = versionParser.safeParse(version);
		assertNull(output);
	}

	@Test
	@Tag("valid")
	public void testParseWildcardVersionString() {
		String version = "1.x.x";
		Version output = versionParser.safeParse(version);
		assertNotNull(output);
		assertEquals(1, output.getMajor().intValue());
		assertEquals(999, output.getMinor().intValue());
		assertEquals(999, output.getPatch().intValue());
	}

	@Test
	@Tag("valid")
	public void testParseQualifiedVersionString() {
		String version = "1.2.3.RELEASE";
		Version output = versionParser.safeParse(version);
		assertNotNull(output);
		assertEquals(1, output.getMajor().intValue());
		assertEquals(2, output.getMinor().intValue());
		assertEquals(3, output.getPatch().intValue());
		assertEquals("RELEASE", output.getQualifier().getId());
	}

}