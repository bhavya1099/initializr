/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=hashCode_2313d163f4
ROOST_METHOD_SIG_HASH=hashCode_44411a81c8

Scenario 1: Verifying hashCode for matching properties and values
  Details:
    TestName: testHashCodeMatch.
    Description: To verify if hashCode generated for an instance of VersionReference with particular property and value matches with properties and values used to initialize it.
  Execution:
    Arrange: Initialize an instance of VersionReference with a defined property and value.
    Act: Generate hashCode for this initialized instance of VersionReference.
    Assert: Compare the hashCode generated with Objects.hash of the property and value used to initialize.
  Validation:
    The hashCode should match and equal the Objects.hash of the property and value. This indicates that Objectâ€™s own hashCode generator is working accurately.

Scenario 2: Verifying hashCode for non-matching properties and values
  Details:
    TestName: testHashCodeNoMatch.
    Description: To validate if hashcode generated for an instance of VersionReference with defined property and value does not match with different properties and values.
  Execution:
    Arrange: Initialize one instance of VersionReference with a known property and value, and another with different property and value.
    Act: Generate hashCode for both instances.
    Assert: Verify that the hashCodes generated are not equal.
  Validation:
    The hashCodes should not match as they indicate two distinct objects. It would ensure the uniqueness of the hash method and support the reliability of the data structure while handling different objects.

Scenario 3: Verifying hashCode consistency
  Details:
    TestName: testHashCodeConsistency.
    Description: This test verifies if multiple invocations of hashCode on the same object consistently returns the same integer.
  Execution:
    Arrange: Initialize an instance of VersionReference with a defined property and value.
    Act: Invoke hashCode method multiple times on this instance.
    Assert: Assert that they all return the same result.
  Validation:
    If the hashCode method provides the same output for multiple invocations on the same object, this confirms the method's consistency.

Scenario 4: Verifying hashCode for null values
  Details:
    TestName: testHashCodeWithNullValues.
    Description: This test aims to verify if hashCode method handles the null values gracefully.
  Execution:
    Arrange: Create two instances of VersionReference with null value for both property and value.
    Act: Generate hashCode for both these instances.
    Assert: Assert that both hashCodes are equal.
  Validation:
    The hashCodes generated should be equal, indicating that the hashCode method successfully handles null values. This is significant for preventing potential null-pointer exceptions and maintaining robustness.,
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import java.util.Objects;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Assertions;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.junit.jupiter.api.*;

public class VersionReferenceHashCodeTest {

	@Test
	@Tag("valid")
	public void testHashCodeMatch() {
		VersionProperty property = VersionProperty.of("property", true);
		String value = "value";
		VersionReference instance = VersionReference.ofProperty(property);
		int hashCode = instance.hashCode();
		Assertions.assertEquals(Objects.hash(property, value), hashCode,
				"Hash code does not match Objects.hash of properties");
	}

	@Test
	@Tag("invalid")
	public void testHashCodeNoMatch() {
		VersionProperty property = VersionProperty.of("property", true);
		VersionProperty diffProperty = VersionProperty.of("diffProperty", false);
		String value = "value";
		String diffValue = "diffValue";
		VersionReference instance1 = VersionReference.ofProperty(property);
		VersionReference instance2 = VersionReference.ofValue(diffValue);
		Assertions.assertNotEquals(instance1.hashCode(), instance2.hashCode(),
				"Hash codes should not match for different objects");
	}

	@Test
	@Tag("valid")
	public void testHashCodeConsistency() {
		VersionProperty property = VersionProperty.of("property", true);
		VersionReference instance = VersionReference.ofProperty(property);
		int hashCode1 = instance.hashCode();
		int hashCode2 = instance.hashCode();
		Assertions.assertEquals(hashCode1, hashCode2,
				"Hash codes should match for multiple invocations on the same object");
	}

	@Test
	@Tag("boundary")
	public void testHashCodeWithNullValues() {
		VersionReference instance1 = VersionReference.ofValue(null);
		VersionReference instance2 = VersionReference.ofProperty(null);
		Assertions.assertEquals(instance1.hashCode(), instance2.hashCode(), "Hash codes should match for null values");
	}

}