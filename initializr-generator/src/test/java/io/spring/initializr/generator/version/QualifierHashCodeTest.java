/*
 * Copyright 2012-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=hashCode_293d28767a
ROOST_METHOD_SIG_HASH=hashCode_44411a81c8

"""
Scenario 1: Test hashCode method with non-null fields

Details:
  TestName: testHashCodeWithNonNullFields
  Description: This test is designed to check if the hashCode method is functioning properly when all fields are non-null. This scenario is important as it represents the nominal case, and ensuring that the hashCode consistently identifies unique objects is imperative for instance equality checks.
Execution:
  Arrange: Create two objects of type Qualifier with identical properties.
  Act: Generate a hashcode for each object using the hashCode() method.
  Assert: Assert both hashcodes are identical using JUnit's assertEquals().
Validation:
  This will validate if the hashCode is correctly calculating and returning the same hash for two objects with the same properties. This is required for the proper functioning of Classes that rely on hash-based collections like HashSet and HashMap.

Scenario 2: Test hashCode method for different Qualifiers

Details:
  TestName: testHashCodeForDifferentQualifiers
  Description: This test is designed to confirm if the hashCode method generates different hash codes for different qualifiers. As the hash code is used for performing quick uniqueness checks, it is critical to ensure dissimilar Qualifiers produce distinct hash codes.
Execution:
  Arrange: Create two objects of type Qualifier with different properties.
  Act: Generate a hashcode for each object using hashCode() method.
  Assert: Assert hashcodes are different using JUnit's assertNotEquals().
Validation:
  This test ensures that the hashCode method calculates unique hash codes for different qualifier objects. Generating unique hashes for each unequal instance is important for the robust implementation of hash-based collections.

Scenario 3: Test hashCode method for null fields

Details:
  TestName: testHashCodeForNullFields
  Description: This test is to verify the functionality of the hashCode method when one or more of the Qualifier fields are null. This test is crucial for ensuring the method can handle null fields without throwing NullPointerException.
Execution:
  Arrange: Create an object of Qualifier with one or more null fields.
  Act: Generate a hashcode using the hashCode() method of Qualifier.
  Assert: Assert the hashCode does not throw a NullPointerException using JUnit's assertDoesNotThrow().
Validation:
  The assertion aims to verify that the hashCode method handles null fields gracefully and doesn't throw a NullPointerException. It is crucial as it means the object can handle missing values, contributing to robustness in real-world scenarios where data may not always be complete.
""",
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.*;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.function.Function;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

public class QualifierHashCodeTest {

	@Test
	@Tag("valid")
	public void testHashCodeWithNonNullFields() {
		Version version = new Version();
		Version.Qualifier qualifier1 = version.new Qualifier("ID1", 1, ".");
		Version.Qualifier qualifier2 = version.new Qualifier("ID1", 1, ".");

		int hashCode1 = qualifier1.hashCode();
		int hashCode2 = qualifier2.hashCode();

		Assertions.assertEquals(hashCode1, hashCode2,
				"Hash codes of Qualifiers with identical properties should match.");
	}

	@Test
	@Tag("valid")
	public void testHashCodeForDifferentQualifiers() {
		Version version = new Version();
		Version.Qualifier qualifier1 = version.new Qualifier("ID1", 1, ".");
		Version.Qualifier qualifier2 = version.new Qualifier("ID2", 2, "-");

		int hashCode1 = qualifier1.hashCode();
		int hashCode2 = qualifier2.hashCode();

		Assertions.assertNotEquals(hashCode1, hashCode2,
				"Hash codes of Qualifiers with different properties should not match.");
	}

	@Test
	@Tag("boundary")
	public void testHashCodeForNullFields() {
		Assertions.assertDoesNotThrow(() -> {
			Version version = new Version();
			Version.Qualifier qualifier = version.new Qualifier(null, null, null);

			int hashCode = qualifier.hashCode();
		}, "Hash code calculation for a Qualifier with null properties should not throw any exception.");
	}

}