/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=matches_1f53039824
ROOST_METHOD_SIG_HASH=matches_581ac7587e

"""
  Scenario 1: Testing the matches method with valid `ProjectDescription`, `ConditionContext` and `AnnotatedTypeMetadata`

  Details:
    TestName: validMatchTest.
    Description: This test will verify the proper functioning of the matches method when provided with valid arguments.
  Execution:
    Arrange: Mock `ProjectDescription`, `ConditionContext`, and `AnnotatedTypeMetadata` classes.
    Act: Call `matches` method with the mock objects as parameters.
    Assert: Assert that the returned value is as expected.
  Validation:
    This test ensures that the matches method returns the correct result when provided with valid parameters. We assume that the abstract method matches works as mentioned.

  Scenario 2: Testing the matches method with `null` `ProjectDescription`

  Details:
    TestName: nullProjectDescriptionTest.
    Description: This test will verify that the matches method can handle a `null` `ProjectDescription`.
  Execution:
    Arrange: Mock `ConditionContext` and `AnnotatedTypeMetadata`, and set `ProjectDescription` to `null`.
    Act: Call `matches` method with the mock objects and `null` as parameters.
    Assert: Assert that the returned value is as expected or an exception is thrown.
  Validation:
    If the method is not capable of handling null parameters, we can use this test to identify and fix the issue.

  Scenario 3: Testing the matches method with `null` `ConditionContext`

  Details:
    TestName: nullConditionContextTest.
    Description: This test aims to check if an appropriate exception or error handling occurs when a `null` `ConditionContext` is passed in.
  Execution:
    Arrange: Mock `ProjectDescription` and `AnnotatedTypeMetadata`, and set `ConditionContext` to `null`.
    Act: Call the `matches` method with the null `ConditionContext` and the mock objects as parameters.
    Assert: Check whether an exception is thrown.
  Validation:
    This test tests the robustness of the matches method in handling unexpected `null` inputs and ensure it doesn't cause the application to crash.

  Scenario 4: Testing the matches method with `null` `AnnotatedTypeMetadata`

  Details:
    TestName: nullAnnotatedTypeMetadataTest.
    Description: The target of this test is to examine how the matches method deals with a `null` `AnnotatedTypeMetadata` parameter.
  Execution:
    Arrange: Mock `ProjectDescription` and `ConditionContext`, and set `AnnotatedTypeMetadata` to `null`.
    Act: Invoke the `matches` method with the `null` `AnnotatedTypeMetadata` and the mock objects.
    Assert: Validate that an exception is thrown.
  Validation:
    This scenario checks if the matches method can prevent unhandled exceptions when processing `null` inputs, which are often overlooked in development.

"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.condition;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mockito;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import io.spring.initializr.generator.project.ProjectDescription;
import org.springframework.context.annotation.Condition;

public class ProjectGenerationConditionMatchesTest {

	private ProjectGenerationCondition projectGenerationCondition;

	private ConditionContext context;

	private ProjectDescription description;

	private AnnotatedTypeMetadata metadata;

	@BeforeEach
	public void init() {
		context = mock(ConditionContext.class);
		description = mock(ProjectDescription.class);
		metadata = mock(AnnotatedTypeMetadata.class);
		projectGenerationCondition = new ProjectGenerationCondition() {
			@Override
			public boolean matches(ProjectDescription description, ConditionContext context,
					AnnotatedTypeMetadata metadata) {
				return true;
			}
		};
		BeanFactory beanFactory = mock(BeanFactory.class);
		when(context.getBeanFactory()).thenReturn(beanFactory);
		when(beanFactory.getBean(ProjectDescription.class)).thenReturn(description);
	}

	@Tag("valid")
	@Test
	public void validMatchTest() {
		assertTrue(projectGenerationCondition.matches(context, metadata));
	}

	@Tag("invalid")
    @Test
    public void nullProjectDescriptionTest() {
        when(context.getBeanFactory().getBean(ProjectDescription.class)).thenReturn(null);
        assertThrows(RuntimeException.class, () -> projectGenerationCondition.matches(context, metadata));
    }

	@Tag("invalid")
	@Test
	public void nullConditionContextTest() {
		assertThrows(RuntimeException.class, () -> projectGenerationCondition.matches(null, metadata));
	}

	@Tag("invalid")
	@Test
	public void nullAnnotatedTypeMetadataTest() {
		assertThrows(RuntimeException.class, () -> projectGenerationCondition.matches(context, null));
	}

	@AfterEach
	public void cleanup() {
		Mockito.reset(context, description, metadata);
	}

}