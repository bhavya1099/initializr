/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=dependenciesV21_bfa2b5a6e7
ROOST_METHOD_SIG_HASH=dependenciesV21_bfa2b5a6e7

"""
Scenario 1: Successful retrieval of application dependencies for a specified boot version

Details:
  TestName: retrieveDependenciesSuccessfullyWithGivenBootVersion
  Description: This test will ensure that the dependenciesV21 function is able to successfully return application dependencies for a valid specified boot version.
Execution:
  Arrange: Mock the affirmative responses for compatibility check and metadata retrieval.
  Act: Invoke dependenciesV21() with a valid boot version value.
  Assert: Verify that the ResponseEntity returned is instance of 'ResponseEntity', HttpStatus is 'OK', and the MediaType is 'application/vnd.initializr.v2.1+json' or 'application/json'.
Validation:
  The assertion verifies that the target method successfully handles valid requests and provides appropriate response. This is important to ensure that the correct metadata is provided to the client application during initialization.

Scenario 2: Request for application dependencies with an unsupported boot version

Details:
  TestName: handleUnsupportedBootVersion
  Description: This test case is designed to check whether the function can handle the request for an unsupported boot version properly by throwing InvalidProjectRequestException.
Execution:
  Arrange: Mock the behavior of platform compatibility check to return false.
  Act: Invoke dependenciesV21() with an unsupported boot version value.
  Assert: Verify that the function has thrown InvalidProjectRequestException.
Validation:
  The assertion verifies that unsupported boot versions are not processed further causing any unpredictable behaviours. It will ensure that the system is resilient and can handle edge cases.

Scenario 3: dependenciesV21 handling when null is passed as bootVersion

Details:
  TestName: handleDependenciesRequestWithNullBootVersion
  Description: This test scenario validates if the dependenciesV21 function retrieves the metadata by default when null is passed as 'bootVersion' parameter, without causing any exceptions or failures.
Execution:
  Arrange: Mock the functions for retrieving default boot version and dependency metadata.
  Act: Invoke dependenciesV21() with null as boot version.
  Assert: Check that the ResponseEntity returned is instance of 'ResponseEntity', HttpStatus is 'OK', and the MediaType is 'application/vnd.initializr.v2.1+json' or 'application/json'.
Validation:
  The assertion verifies that the target method effectively handles null input scenario, using the default boot version for metadata retrieval. This ensures that the system remains robust and debugged for all valid conditions.
"""
*/

// ********RoostGPT********

package io.spring.initializr.web.controller;

import io.spring.initializr.generator.version.Version;
import io.spring.initializr.metadata.DependencyMetadata;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import io.spring.initializr.metadata.InvalidProjectRequestException;
import io.spring.initializr.metadata.DependencyMetadataProvider;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.io.IOException;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import java.util.concurrent.TimeUnit;
import io.spring.initializr.metadata.InitializrConfiguration.Platform;
import io.spring.initializr.metadata.InvalidInitializrMetadataException;
import io.spring.initializr.web.mapper.DependencyMetadataJsonMapper;
import io.spring.initializr.web.mapper.DependencyMetadataV21JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataJsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV21JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV22JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataV2JsonMapper;
import io.spring.initializr.web.mapper.InitializrMetadataVersion;
import io.spring.initializr.web.project.InvalidProjectRequestException;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.CacheControl;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

public class ProjectMetadataControllerDependenciesV21Test extends AbstractMetadataController {

	private final InitializrMetadataProvider metadataProvider = mock(InitializrMetadataProvider.class);

	private final DependencyMetadataProvider dependencyMetadataProvider = mock(DependencyMetadataProvider.class);

	private final ProjectMetadataController controller = new ProjectMetadataController(metadataProvider,
			dependencyMetadataProvider);

	@Tag("valid")
	@Test
	void retrieveDependenciesSuccessfullyWithGivenBootVersion() throws IOException {
		String bootVersion = "2.1.1";
		InitializrMetadata metadata = mock(InitializrMetadata.class);
		DependencyMetadata dependencyMetadata = mock(DependencyMetadata.class);
		when(this.metadataProvider.get()).thenReturn(metadata);
		when(this.dependencyMetadataProvider.get(any(), any())).thenReturn(dependencyMetadata);
		ResponseEntity<String> responseEntity = this.controller.dependenciesV21(bootVersion);
		assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
		assertEquals(responseEntity.getHeaders().getContentType().toString(), "application/vnd.initializr.v2.1+json");
	}

	@Tag("invalid")
	@Test
	void handleUnsupportedBootVersion() throws IOException {
		String bootVersion = "0.0.1";
		InitializrMetadata metadata = mock(InitializrMetadata.class);
		DependencyMetadata dependencyMetadata = mock(DependencyMetadata.class);
		when(this.metadataProvider.get()).thenReturn(metadata);
		when(this.dependencyMetadataProvider.get(any(), any())).thenReturn(dependencyMetadata);
		assertThrows(InvalidProjectRequestException.class, () -> {
			this.controller.dependenciesV21(bootVersion);
		});
	}

	@Tag("boundary")
	@Test
	void handleDependenciesRequestWithNullBootVersion() {
		String bootVersion = null;
		InitializrMetadata metadata = mock(InitializrMetadata.class);
		DependencyMetadata dependencyMetadata = mock(DependencyMetadata.class);
		when(this.metadataProvider.get()).thenReturn(metadata);
		when(this.dependencyMetadataProvider.get(any(), any())).thenReturn(dependencyMetadata);
		ResponseEntity<String> responseEntity = this.controller.dependenciesV21(bootVersion);
		assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
		assertEquals(responseEntity.getHeaders().getContentType().toString(), "application/vnd.initializr.v2.1+json");
	}

}