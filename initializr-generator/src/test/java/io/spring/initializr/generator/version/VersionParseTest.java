/*
 * Copyright 2012-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=parse_a7b112e113
ROOST_METHOD_SIG_HASH=parse_eb83429b4e

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/java-report-test/d5958c2d-2a99-46e6-ba3d-f7c9d8576735/source/initializr/initializr-generator/src/test/java/io/spring/initializr/generator/version/VersionTests.java
Tests:
    "@Test
@Test
void equalNoQualifier() {
    Version first = parse("1.2.0");
    Version second = parse("1.2.0");
    assertThat(first).isEqualByComparingTo(second);
    assertThat(first).isEqualTo(second);
}
"
    "@Test
@Test
void equalQualifierNoVersion() {
    Version first = parse("1.2.0.RELEASE");
    Version second = parse("1.2.0.RELEASE");
    assertThat(first).isEqualByComparingTo(second);
    assertThat(first).isEqualTo(second);
}
"
    "@Test
@Test
void equalQualifierVersion() {
    Version first = parse("1.2.0.RC1");
    Version second = parse("1.2.0.RC1");
    assertThat(first).isEqualByComparingTo(second);
    assertThat(first).isEqualTo(second);
}
"
    "@Test
@Test
void compareMajorOnly() {
    assertThat(parse("2.2.0")).isGreaterThan(parse("1.8.0"));
}
"
    "@Test
@Test
void compareMinorOnly() {
    assertThat(parse("2.2.0")).isGreaterThan(parse("2.1.9"));
}
"
    "@Test
@Test
void comparePatchOnly() {
    assertThat(parse("2.2.4")).isGreaterThan(parse("2.2.3"));
}
"
    "@Test
@Test
void compareHigherVersion() {
    assertThat(parse("1.2.0.RELEASE")).isGreaterThan(parse("1.1.9.RELEASE"));
}
"
    "@Test
@Test
void compareHigherQualifier() {
    assertThat(parse("1.2.0.RC1")).isGreaterThan(parse("1.2.0.M1"));
}
"
    "@Test
@Test
void compareHigherQualifierVersion() {
    assertThat(parse("1.2.0.RC2")).isGreaterThan(parse("1.2.0.RC1"));
}
"
    "@Test
@Test
void compareLowerVersion() {
    assertThat(parse("1.0.5.RELEASE")).isLessThan(parse("1.1.9.RELEASE"));
}
"
    "@Test
@Test
void compareLowerQualifier() {
    assertThat(parse("1.2.0.RC1")).isLessThan(parse("1.2.0.RELEASE"));
}
"
    "@Test
@Test
void compareLessQualifierVersion() {
    assertThat(parse("1.2.0.RC2")).isLessThan(parse("1.2.0.RC3"));
}
"
    "@Test
@Test
void compareWithNull() {
    assertThat(parse("1.2.0.RC2")).isGreaterThan(null);
}
"
    "@Test
@Test
void compareUnknownQualifier() {
    assertThat(parse("1.2.0.Beta")).isLessThan(parse("1.2.0.CR"));
}
"
    "@Test
@Test
void compareUnknownQualifierVersion() {
    assertThat(parse("1.2.0.Beta1")).isLessThan(parse("1.2.0.Beta2"));
}
"
    "@Test
@Test
void snapshotGreaterThanRC() {
    assertThat(parse("1.2.0.BUILD-SNAPSHOT")).isGreaterThan(parse("1.2.0.RC1"));
}
"
    "@Test
@Test
void snapshotLowerThanRelease() {
    assertThat(parse("1.2.0.BUILD-SNAPSHOT")).isLessThan(parse("1.2.0.RELEASE"));
}
"
    "@Test
@Test
void formatV1toV1() {
    Version version = Version.parse("1.2.0.RELEASE");
    assertThat(version.format(Format.V1)).isSameAs(version);
}
"
    "@Test
@Test
void formatV1SnapshotToV2() {
    Version version = Version.parse("1.2.0.BUILD-SNAPSHOT");
    assertThat(version.format(Format.V2)).hasToString("1.2.0-SNAPSHOT");
}
"
    "@Test
@Test
void formatV1GAToV2() {
    Version version = Version.parse("1.2.0.RELEASE");
    assertThat(version.format(Format.V2)).hasToString("1.2.0");
}
"
    "@Test
@Test
void formatNoQualifierToV1() {
    Version version = Version.parse("1.2.0");
    assertThat(version.format(Format.V1)).hasToString("1.2.0.RELEASE");
}
"
    "@Test
@Test
void formatV2toV2() {
    Version version = Version.parse("1.2.0-RC1");
    assertThat(version.format(Format.V2)).isSameAs(version);
}
"
    "@Test
@Test
void formatV2SnapshotToV1() {
    Version version = Version.parse("1.2.0-SNAPSHOT");
    assertThat(version.format(Format.V1)).hasToString("1.2.0.BUILD-SNAPSHOT");
}
"
    "@Test
@Test
void formatV2GAToV1() {
    Version version = Version.parse("1.2.0");
    assertThat(version.format(Format.V1)).hasToString("1.2.0.RELEASE");
}
"
    "@Test
@Test
void formatNoQualifierToV2() {
    Version version = Version.parse("1.2.0");
    assertThat(version.format(Format.V2)).hasToString("1.2.0");
}
"
    "@Test
private Version parse(String text) {
    return this.parser.parse(text);
}
"

File Path: /var/tmp/Roost/RoostGPT/java-report-test/d5958c2d-2a99-46e6-ba3d-f7c9d8576735/source/initializr/initializr-generator/src/test/java/io/spring/initializr/generator/version/VersionRangeTests.java
Tests:
    "@Test
@Test
void matchLatestVersion() {
    assertThat("1.2.8.RELEASE").is(match("[1.2.0.RELEASE,1.2.x.BUILD-SNAPSHOT]", new VersionParser(Collections.singletonList(Version.parse("1.2.9.BUILD-SNAPSHOT")))));
}
"
    "@Test
@Test
void matchOverLatestVersion() {
    assertThat("1.2.10.RELEASE").isNot(match("[1.2.0.RELEASE,1.2.x.BUILD-SNAPSHOT]", new VersionParser(Collections.singletonList(Version.parse("1.2.9.BUILD-SNAPSHOT")))));
}
"
    "@Test
@Test
void matchAsOfCurrentVersion() {
    assertThat("1.3.5.RELEASE").is(match("[1.3.x.RELEASE,1.3.x.BUILD-SNAPSHOT]", new VersionParser(Arrays.asList(Version.parse("1.3.4.RELEASE"), Version.parse("1.3.6.BUILD-SNAPSHOT")))));
}
"
    "@Test
@Test
void matchOverAsOfCurrentVersion() {
    assertThat("1.3.5.RELEASE").isNot(match("[1.3.x.RELEASE,1.3.x.BUILD-SNAPSHOT]", new VersionParser(Arrays.asList(Version.parse("1.3.7.RELEASE"), Version.parse("1.3.6.BUILD-SNAPSHOT")))));
}
"
    "@Test
@Test
void simpleStartingRange() {
    assertThat(new VersionRange(Version.parse("1.3.0.RELEASE")).toString()).isEqualTo(">=1.3.0.RELEASE");
}
"
    "@Test
@Test
void toVersionRangeWithSimpleVersion() {
    VersionRange range = new VersionParser(Collections.singletonList(Version.parse("1.5.6.RELEASE"))).parseRange("1.3.5.RELEASE");
    assertThat(range.toRangeString()).isEqualTo("1.3.5.RELEASE");
}
"
    "@Test
@Test
void toVersionRangeWithVersionsIncluded() {
    VersionRange range = new VersionParser(Collections.singletonList(Version.parse("1.5.6.RELEASE"))).parseRange("[1.3.5.RELEASE,1.5.5.RELEASE]");
    assertThat(range.toRangeString()).isEqualTo("[1.3.5.RELEASE,1.5.5.RELEASE]");
}
"
    "@Test
@Test
void toVersionRangeWithLowerVersionExcluded() {
    VersionRange range = new VersionParser(Collections.singletonList(Version.parse("1.5.6.RELEASE"))).parseRange("(1.3.5.RELEASE,1.5.5.RELEASE]");
    assertThat(range.toRangeString()).isEqualTo("(1.3.5.RELEASE,1.5.5.RELEASE]");
}
"
    "@Test
@Test
void toVersionRangeWithHigherVersionExcluded() {
    VersionRange range = new VersionParser(Collections.singletonList(Version.parse("1.5.6.RELEASE"))).parseRange("[1.3.5.RELEASE,1.5.5.RELEASE)");
    assertThat(range.toRangeString()).isEqualTo("[1.3.5.RELEASE,1.5.5.RELEASE)");
}
"
    "@Test
@Test
void toVersionRangeWithVersionsExcluded() {
    VersionRange range = new VersionParser(Collections.singletonList(Version.parse("1.5.6.RELEASE"))).parseRange("(1.3.5.RELEASE,1.5.5.RELEASE)");
    assertThat(range.toRangeString()).isEqualTo("(1.3.5.RELEASE,1.5.5.RELEASE)");
}
"
    "@Test
@Test
void formatLowerOnlyV1toV2() {
    VersionRange range = parse("1.2.0.RELEASE").format(Format.V2);
    assertThat(range.toRangeString()).isEqualTo("1.2.0");
}
"
    "@Test
@Test
void formatV1toV2() {
    VersionRange range = parse("[1.2.0.RELEASE,1.3.0.M1)").format(Format.V2);
    assertThat(range.toRangeString()).isEqualTo("[1.2.0,1.3.0-M1)");
}
"
    "@Test
@Test
void formatLowerOnlyV2toV1() {
    VersionRange range = parse("1.2.0").format(Format.V1);
    assertThat(range.toRangeString()).isEqualTo("1.2.0.RELEASE");
}
"
    "@Test
@Test
void formatV2toV1() {
    VersionRange range = parse("[1.2.0,1.3.0-M1)").format(Format.V1);
    assertThat(range.toRangeString()).isEqualTo("[1.2.0.RELEASE,1.3.0.M1)");
}
"
    "@Test
private static VersionRange parse(String text) {
    return new VersionParser(Collections.emptyList()).parseRange(text);
}
"

File Path: /var/tmp/Roost/RoostGPT/java-report-test/d5958c2d-2a99-46e6-ba3d-f7c9d8576735/source/initializr/initializr-generator/src/test/java/io/spring/initializr/generator/version/VersionParserTests.java
Tests:
    "@Test
@Test
void versionWithNoQualifier() {
    Version version = this.parser.parse("1.2.0");
    assertThat(version.toString()).isEqualTo("1.2.0");
}
"
    "@Test
@Test
void versionWithQualifierAndDotSeparator() {
    Version version = this.parser.parse("1.2.0.RELEASE");
    assertThat(version.toString()).isEqualTo("1.2.0.RELEASE");
}
"
    "@Test
@Test
void versionWithQualifierAndDashSeparator() {
    Version version = this.parser.parse("1.2.0-SNAPSHOT");
    assertThat(version.toString()).isEqualTo("1.2.0-SNAPSHOT");
}
"
    "@Test
@Test
void versionWithQualifierVersionAndDotSeparator() {
    Version version = this.parser.parse("1.2.0.RC2");
    assertThat(version.toString()).isEqualTo("1.2.0.RC2");
}
"
    "@Test
@Test
void versionWithQualifierVersionAndDashSeparator() {
    Version version = this.parser.parse("1.2.0-M3");
    assertThat(version.toString()).isEqualTo("1.2.0-M3");
}
"
    "@Test
@Test
void parseInvalidVersion() {
    assertThatExceptionOfType(InvalidVersionException.class).isThrownBy(() -> this.parser.parse("foo"));
}
"
    "@Test
@Test
void parseVersionWithSpaces() {
    assertThat(this.parser.parse("    1.2.0.RC3  ")).isLessThan(this.parser.parse("1.3.0.RELEASE"));
}
"
    "@Test
@Test
void parseVariableVersionMatch() {
    List<Version> currentVersions = Arrays.asList(this.parser.parse("1.3.8.RELEASE"), this.parser.parse("1.3.9.BUILD-SNAPSHOT"));
    this.parser = new VersionParser(currentVersions);
    assertThat(this.parser.parse("1.3.x.BUILD-SNAPSHOT").toString()).isEqualTo("1.3.9.BUILD-SNAPSHOT");
}
"
    "@Test
@Test
void parseVariableVersionNoPatchMatch() {
    List<Version> currentVersions = Arrays.asList(this.parser.parse("1.3.8.RELEASE"), this.parser.parse("1.3.9.BUILD-SNAPSHOT"));
    this.parser = new VersionParser(currentVersions);
    assertThat(this.parser.parse("1.x.x.RELEASE").toString()).isEqualTo("1.3.8.RELEASE");
}
"
    "@Test
@Test
void parseVariableVersionNoQualifierMatch() {
    List<Version> currentVersions = Arrays.asList(this.parser.parse("1.3.8.RELEASE"), this.parser.parse("1.4.0.BUILD-SNAPSHOT"));
    this.parser = new VersionParser(currentVersions);
    assertThat(this.parser.parse("1.4.x").toString()).isEqualTo("1.4.0.BUILD-SNAPSHOT");
}
"
    "@Test
@Test
void parseVariableVersionNoMatch() {
    List<Version> currentVersions = Arrays.asList(this.parser.parse("1.3.8.RELEASE"), this.parser.parse("1.3.9.BUILD-SNAPSHOT"));
    this.parser = new VersionParser(currentVersions);
    assertThat(this.parser.parse("1.4.x.BUILD-SNAPSHOT").toString()).isEqualTo("1.4.999.BUILD-SNAPSHOT");
}
"
    "@Test
@Test
void parseVariableVersionNoPatchNoMatch() {
    List<Version> currentVersions = Arrays.asList(this.parser.parse("1.3.8.RELEASE"), this.parser.parse("1.3.9.BUILD-SNAPSHOT"));
    this.parser = new VersionParser(currentVersions);
    assertThat(this.parser.parse("2.x.x.RELEASE").toString()).isEqualTo("2.999.999.RELEASE");
}
"
    "@Test
@Test
void parseVariableVersionNoQualifierNoMatch() {
    List<Version> currentVersions = Arrays.asList(this.parser.parse("1.3.8.RELEASE"), this.parser.parse("1.4.0.BUILD-SNAPSHOT"));
    this.parser = new VersionParser(currentVersions);
    assertThat(this.parser.parse("1.2.x").toString()).isEqualTo("1.2.999");
}
""""
Scenario 1: Parsing of a valid version string using the parse method
Details:
  TestName: testParseForValidVersion
  Description: The test would confirm if the parse method is able to convert a valid version string to a Version object correctly.
Execution:
  Arrange: A valid version string, say "1.2.3.RELEASE".
  Act: Invoke the parse(...) method with the valid version string.
  Assert: The returned Version object fields (major, minor, patch, qualifier, format) must match with the parsed version string.
Validation:
  This test would confirm the conversion of a valid version string to a Version object and hence is fundamental to the operation of the Version class.

Scenario 2: Parsing of an invalid version string using the parse method
Details:
  TestName: testParseForInvalidVersion
  Description: This test will verify the functionality when an invalid version string is attempted to be parsed.
Execution:
  Arrange: An invalid version string, say "1.X.3.RELEASE".
  Act: Invoke the parse(...) method with the invalid version string.
  Assert: An exception (like InvalidVersionException) should be thrown.
Validation:
  Confirming the behaviour in case of invalid input is crucial to ensure reliable parsing.

Scenario 3: Test to ensure parse method is non-destructive
Details:
  TestName: testNonDestructiveParsing
  Description: This test is to ensure the parse method does not mutate any versions already parsed and stored.
Execution:
  Arrange: Two valid version strings, say "1.2.3.RELEASE" and "1.3.4.SNAPSHOT".
  Act: Invoke the parse(...) method with the two version strings sequentially.
  Assert: Each call to the parse(...) method should return a unique Version object, and must not change previously parsed Version objects.
Validation:
  This test ensures that the parse method is non-destructive i.e., parsing a new version string does not affect Version(s) parsed earlier.

Scenario 4: Parsing of a null string using the parse method
Details:
  TestName: testParseForNullVersion
  Description: This test will verify the functionality when a null string is attempted to be parsed.
Execution:
  Arrange: A null string.
  Act: Invoke the parse(...) method with the null string.
  Assert: An appropriate exception (like NullPointerException) should be thrown.
Validation:
  This test validates the fail-safe operation of the parse method against null inputs.
"""
,
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import com.google.code.findbugs.annotations.SuppressFBWarnings;
import org.junit.jupiter.api.*;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.function.Function;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

class VersionParseTest {

	@Test
	@Tag("valid")
	@SuppressFBWarnings(value = "DMI_HARDCODED_ABSOLUTE_FILENAME")
	public void testParseForValidVersion() {
		Version resultVersion = Version.parse("1.2.3.RELEASE");
		assertNotNull(resultVersion);
		assertEquals(1, resultVersion.getMajor());
		assertEquals(2, resultVersion.getMinor());
		assertEquals(3, resultVersion.getPatch());
		Version.Qualifier qualifier = resultVersion.getQualifier();
		assertEquals("RELEASE", qualifier.getId());
		assertNull(qualifier.getVersion());
		assertEquals(".", qualifier.getSeparator());
	}

	@Test
	@Tag("invalid")
	public void testParseForInvalidVersion() {
		assertThrows(InvalidVersionException.class, () -> Version.parse("1.X.3.RELEASE"));
	}

	@Test
	@Tag("valid")
	public void testNonDestructiveParsing() {
		Version version1 = Version.parse("1.2.3.RELEASE");
		Version version2 = Version.parse("1.3.4.SNAPSHOT");
		assertNotSame(version1, version2);
		assertEquals(1, version1.getMajor());
		assertEquals(2, version1.getMinor());
		assertEquals(3, version1.getPatch());
		Version.Qualifier qualifier1 = version1.getQualifier();
		assertEquals("RELEASE", qualifier1.getId());
		assertNull(qualifier1.getVersion());
		assertEquals(".", qualifier1.getSeparator());
		assertEquals(1, version2.getMajor());
		assertEquals(3, version2.getMinor());
		assertEquals(4, version2.getPatch());
		Version.Qualifier qualifier2 = version2.getQualifier();
		assertEquals("SNAPSHOT", qualifier2.getId());
		assertNull(qualifier2.getVersion());
		assertEquals(".", qualifier2.getSeparator());
	}

	@Test
	@Tag("boundary")
	public void testParseForNullVersion() {
		assertThrows(NullPointerException.class, () -> Version.parse(null));
	}

}