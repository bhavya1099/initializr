/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=generateAppUrl_c0bd08f76a
ROOST_METHOD_SIG_HASH=generateAppUrl_952bf58219

"""
Scenario 1: Valid HTTP URI Generation

Details:
  TestName: generateHttpAppUrlCheck
  Description: This test intends to verify if 'generateAppUrl' method can properly generate a standard HTTP URI when the 'forceSsl' attribute is set to 'false'.
Execution:
  Arrange: Set mock for 'ServletUriComponentsBuilder'.
           Make sure 'forceSsl' attribute is set as 'false'.
  Act: Invoke 'generateAppUrl' method.
  Assert: The returned value should begin with 'http://'.
Validation:
  The assertion confirms that the URI has been successfully generated. If SSL forcing is disabled, it signifies that proper HTTP URI has been created. This ensures correct server configuration during deployment.

Scenario 2: Valid HTTPS URI Generation

Details:
  TestName: generateHttpsAppUrlCheck
  Description: This test ensures that 'generateAppUrl' method correctly transforms generated URI to enforce SSL when 'forceSsl' attribute is 'true'.
Execution:
  Arrange: Set mock for 'ServletUriComponentsBuilder'.
           Set 'forceSsl' attribute as 'true'.
  Act: Call 'generateAppUrl' method.
  Assert: The returned value should begin with 'https://'.
Validation:
  The assertion validates that SSL has been accurately enforced in the generated URI. This verification is crucial for secure applications, guaranteeing safe communication over the network.

Scenario 3: UriComponentsBuilder Exception

Details:
  TestName: generateAppUrlWhenUriComponentsBuilderFails
  Description: This test aims to verify the behavior of 'generateAppUrl' method when 'UriComponentsBuilder' cannot initialise a URI correctly, either due to an invalid protocol or a malfunctioning server environment.
Execution:
  Arrange: Set mock for 'ServletUriComponentsBuilder' to throw a generic exception.
           Keep the 'forceSsl' field as either 'true' or 'false'.
  Act: Try to execute 'generateAppUrl' method.
  Assert: Expect an exception to be thrown.
Validation:
  The test validates that the application safely handles any exceptions thrown during URI creation. This is crucial to prevent system crashes or unhandled exceptions that could lead to vulnerabilities or operational issues.
"""
*/

// ********RoostGPT********

package io.spring.initializr.web.controller;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.util.UriComponentsBuilder;
import org.junit.jupiter.api.*;
import java.nio.charset.StandardCharsets;
import org.springframework.util.DigestUtils;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

public class AbstractMetadataControllerGenerateAppUrlTest {

	@Tag("valid")
	@Test
	public void generateHttpAppUrlCheck() {
		InitializrMetadataProvider metadataProvider = mock(InitializrMetadataProvider.class);
		AbstractMetadataController controller = new AbstractMetadataController(metadataProvider);
		MockHttpServletRequest request = new MockHttpServletRequest();
		RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request));
		assertEquals("http://localhost", controller.generateAppUrl());
	}

	@Tag("valid")
	@Test
	public void generateHttpsAppUrlCheck() {
		InitializrMetadataProvider metadataProvider = mock(InitializrMetadataProvider.class);
		AbstractMetadataController controller = new AbstractMetadataController(metadataProvider) {
			@Override
			protected boolean isForceSsl() {
				return true;
			}
		};
		MockHttpServletRequest request = new MockHttpServletRequest();
		RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request));
		assertEquals("https://localhost", controller.generateAppUrl());
	}

	@Tag("invalid")
    @Test
    public void generateAppUrlWhenUriComponentsBuilderFails() {
        InitializrMetadataProvider metadataProvider = mock(InitializrMetadataProvider.class);
        AbstractMetadataController controller = new AbstractMetadataController(metadataProvider);

        UriComponentsBuilder.fromCurrentServletMapping()
        RequestContextHolder.resetRequestAttributes();
        assertThrows(IllegalStateException.class, () -> controller.generateAppUrl());
    }

}