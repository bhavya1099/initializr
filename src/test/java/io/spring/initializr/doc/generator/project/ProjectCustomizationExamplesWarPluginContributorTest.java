/*
 * Copyright 2012-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=warPluginContributor_495dd4fb10
ROOST_METHOD_SIG_HASH=warPluginContributor_6816e9724d

"""
 Scenario 1: Test whether the warPluginContributor method correctly adds the "war" plugin to the build.

 Details:
    TestName: testWarPluginContributorAddsWarPlugin
    Description: This test ensures that the warPluginContributor function accurately adds the "war" plugin to the build when conditions match.
 Execution:
    Arrange: Mock a GradleBuild object.
    Act: Call the warPluginContributor method to modify the build.
    Assert: Use JUnit assertions to check whether the modified build now contains the "war" plugin.
 Validation:
    This assertion verifies whether the warPluginContributor can accurately add the "war" plugin to builds. This is necessary to ensure that the build system can handle war packaging effectively.


Scenario 2: Test warPluginContributor when the system's build is not Gradle or when packaging isn't war.

  Details:
    TestName: testWarPluginContributorOnNonWarOrNonGradleBuild
    Description: This test checks whether the warPluginContributor function runs when the build system isn't
    Gradle or when the target packaging isn't war.
  Execution:
    Arrange: Mock a build system and packaging that don't correspond to Gradle and war, respectively.
    Act: invoke the warPluginContributor method to try and modify the build.
    Assert: Use JUnit assertion to verify that the "war" plugin hasn't been added to the mock build.
  Validation:
    The assertion checks if the warPluginContributor function correctly checks for the build system and packaging type before modifying the build. This is important to ensure that the function doesn't disrupt builds that it shouldn't modify.

Scenario 3: Test warPluginContributor on a build that already contains the "war" plugin.

  Details:
    TestName: testWarPluginContributorOnBuildWithWar
    Description: This test checks whether the warPluginContributor function modifies a build that already contains the "war" plugin.
  Execution:
    Arrange: Mock a GradleBuild object and add the "war" plugin.
    Act: invoke the warPluginContributor on the build replicate from the arrangement.
    Assert: Use a JUnit assertion to check if the build still only contains one instance of the "war" plugin.
  Validation:
    The assertion verifies whether the warPluginContributor function checks for the presence of the "war" plugin before adding it. This is crucial for preventing duplicate plugins and ensuring the build's integrity.
"""
*/

// ********RoostGPT********

package io.spring.initializr.doc.generator.project;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.mockito.Mockito;
import io.spring.initializr.generator.buildsystem.gradle.GradleBuild;
import io.spring.initializr.generator.buildsystem.gradle.GradleBuildSystem;
import io.spring.initializr.generator.buildsystem.gradle.GradlePluginContainer;
import io.spring.initializr.generator.packaging.war.WarPackaging;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import io.spring.initializr.generator.condition.ConditionalOnBuildSystem;
import io.spring.initializr.generator.condition.ConditionalOnPackaging;
import io.spring.initializr.generator.spring.build.BuildCustomizer;
import org.springframework.context.annotation.Bean;

public class ProjectCustomizationExamplesWarPluginContributorTest {

	@Test
	@Tag("Valid")
	void testWarPluginContributorAddsWarPlugin() {
		// Arrange
		GradleBuild mockBuild = Mockito.mock(GradleBuild.class);
		GradlePluginContainer mockPlugins = Mockito.mock(GradlePluginContainer.class);
		Mockito.when(mockBuild.plugins()).thenReturn(mockPlugins);
		// Act
		ProjectCustomizationExamples projectCustomizationExamples = new ProjectCustomizationExamples();
		projectCustomizationExamples.warPluginContributor().customize(mockBuild);
		// Assert
		Mockito.verify(mockPlugins).add("war");
	}

	@Test
	@Tag("Invalid")
	void testWarPluginContributorOnNonWarOrNonGradleBuild() {
		// TODO: Set up a build and packaging that don't correspond to Gradle and war.
		// This cannot be tested properly within this context due to annotation validators
		// at the method level in the class ProjectCustomizationExamples.
	}

	@Test
	@Tag("Boundary")
	void testWarPluginContributorOnBuildWithWar() {
		// Arrange
		GradleBuild mockBuild = Mockito.mock(GradleBuild.class);
		GradlePluginContainer mockPlugins = Mockito.mock(GradlePluginContainer.class);
		Mockito.when(mockBuild.plugins()).thenReturn(mockPlugins);
		Mockito.when(mockPlugins.has("war")).thenReturn(true);
		// Act
		ProjectCustomizationExamples projectCustomizationExamples = new ProjectCustomizationExamples();
		projectCustomizationExamples.warPluginContributor().customize(mockBuild);
		// Assert
		Mockito.verify(mockPlugins, Mockito.never()).add("war");
	}

}