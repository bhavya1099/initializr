/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=parseRange_b71b5757f6
ROOST_METHOD_SIG_HASH=parseRange_4436c62d5d

"""
Scenario 1: Valid Input Range
Details:
    TestName: testValidInputRange.
    Description: This test is intended to ensure that the method parseRange works as expected when provided a valid range string in the format "[version1, version2]".
Execution:
    Arrange: A valid range string such as "[1.2.3, 2.3.4]" is set as an input.
    Act: Call the parseRange method with the valid range string.
    Assert: Verify that the result is a VersionRange with the lower version as 1.2.3 and upper version as 2.3.4.
Validation:
    The assertion verifies that a valid input is correctly parsed to a VersionRange object. This is crucial as the correct interpretation of version ranges is critical to the functioning of the application.

Scenario 2: Single Version Input
Details:
    TestName: testSingleVersionInput.
    Description: In this scenario, an input string containing a single version should be taken as a valid range with both higher version and lowerInclusive as true.
Execution:
    Arrange: Input string with a single version like "1.2.3" is set.
    Act: Invoke parseRange method with the said string.
    Assert: Check if the resulting VersionRange corresponds to a version range of [1.2.3, null].
Validation:
    This test verifies that an input containing a single version is interpreted as an open-ended version range starting with the given version. This is important as it allows for a flexible interpretation of inputs.

Scenario 3: Invalid Range Format
Details:
    TestName: testInvalidRangeFormat.
    Description: This test case checks that the parseRange method throws an exception as intended when provided with an improperly formatted input string.
Execution:
    Arrange: Create a string that lacks the expected formatting, such as "1.2.3, 2.3.4".
    Act: Invoke the parseRange method with this string.
    Assert: Assert that an InvalidVersionException is thrown.
Validation:
    This test verifies that the function correctly identifies and rejects improperly formatted inputs. This is important as it prevents the application from accepting and acting upon invalid data.

Scenario 4: Null Input
Details:
    TestName: testNullInput.
    Description: This test validates that the parseRange method throws an exception when provided with a null input.
Execution:
    Arrange: Set a null string.
    Act: Invoke parseRange method with the null string.
    Assert: Check if an exception is thrown.
Validation:
    This test ensures that the function correctly identifies and rejects a null input. This is important in preventing null pointer exceptions from disrupting the runtime of the application.
"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import java.util.Collections;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import io.spring.initializr.generator.version.Version.Qualifier;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

public class VersionParserParseRangeTest {

	@Test
	@Tag("valid")
	public void testValidInputRange() {
		VersionParser versionParser = new VersionParser(Collections.emptyList());
		VersionRange versionRange = versionParser.parseRange("[1.2.3, 2.3.4]");
		assertEquals(1, versionRange.getLowerVersion().getMajor());
		assertEquals(2, versionRange.getLowerVersion().getMinor());
		assertEquals(3, versionRange.getLowerVersion().getPatch());
		assertEquals(2, versionRange.getHigherVersion().getMajor());
		assertEquals(3, versionRange.getHigherVersion().getMinor());
		assertEquals(4, versionRange.getHigherVersion().getPatch());
	}

	@Test
	@Tag("valid")
	public void testSingleVersionInput() {
		VersionParser versionParser = new VersionParser(Collections.emptyList());
		VersionRange versionRange = versionParser.parseRange("1.2.3");
		assertEquals(1, versionRange.getLowerVersion().getMajor());
		assertEquals(2, versionRange.getLowerVersion().getMinor());
		assertEquals(3, versionRange.getLowerVersion().getPatch());
		assertNull(versionRange.getHigherVersion());
	}

	@Test
	@Tag("invalid")
	public void testInvalidRangeFormat() {
		VersionParser versionParser = new VersionParser(Collections.emptyList());
		Assertions.assertThrows(InvalidVersionException.class, () -> {
			versionParser.parseRange("1.2.3, 2.3.4");
		});
	}

	@Test
	@Tag("invalid")
	public void testNullInput() {
		VersionParser versionParser = new VersionParser(Collections.emptyList());
		Assertions.assertThrows(InvalidVersionException.class, () -> {
			versionParser.parseRange(null);
		});
	}

}