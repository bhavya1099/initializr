/*
 * Copyright 2012-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=cleanTempFiles_c6aa981e2a
ROOST_METHOD_SIG_HASH=cleanTempFiles_d130d5e1bc

"""
  Scenario 1: Validating the removal and cleaning of temporary files.

  Details:
    TestName: cleanExistingTempFiles.
    Description: This test validates if the cleanTempFiles method properly removes temporary files for the given input directory path. The test ensures that all files in the temporaryFiles map against the directory are removed if they exist.

  Execution:
    Arrange: Create a mock Path instance for the directory and add it to the temporaryFiles map with a list of mock temporary files' Path instances.
    Act: Invoke cleanTempFiles with the mock directory's Path.
    Assert: Assert that the temporaryFiles map does not contain an entry for the mock directory's Path.
  Validation:
    This assertion validates that all temporary files corresponding to the directory were cleaned. Ensuring proper removal of temporary files is vital to maintain effective memory management and to avoid unwanted clutter in the application directories.

  Scenario 2: Cleaning of non-existant temporary files.

  Details:
    TestName:  cleanNonExistentTempFiles.
    Description: This test checks the case where the cleanTempFiles method is asked to clean temporary files for a directory not present in the temporaryFiles map. The test ensures that the method can handle such an occurrence gracefully.

  Execution:
    Arrange: Create a mock Path instance for a directory that is not added to the temporaryFiles map.
    Act: Invoke cleanTempFiles with the mock directory's Path.
    Assert: Check that the temporaryFiles map remains unchanged.
  Validation:
    This assertion confirms that invoking cleanTempFiles with a non-existent directory does not alter the state of the temporaryFiles map. This is essential to ensure the stability and reliability of the method when dealing with directories that may not currently have any associated temporary files.

  Scenario 3: Exception handling when temporary files cannot be deleted.

  Details:
    TestName: handleTempFileDeletingException.
    Description: This test validates whether the cleanTempFiles method can handle exceptions raised during the removal of temp files.

  Execution:
    Arrange: Mock a Path instance for the directory and add it to temporaryFiles map. Arrange the FileSystemUtils.deleteRecursively method to throw an IOException when one of the temporary files is being deleted.
    Act: Invoke cleanTempFiles with the mock directory's path.
    Assert: Assert that the temporaryFiles map does not contain an entry for the mock directory's Path.
  Validation:
    This test ensures that cleanTempFiles handles exceptions gracefully while trying to delete a temporary file. This is essential to ensure the resilience of the application when faced with IO errors or any other unforeseen problems while deleting temporary files.
"""
*/

// ********RoostGPT********

package io.spring.initializr.web.project;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mockito;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.util.FileSystemUtils;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import io.spring.initializr.generator.buildsystem.BuildItemResolver;
import io.spring.initializr.generator.buildsystem.BuildWriter;
import io.spring.initializr.generator.project.DefaultProjectAssetGenerator;
import io.spring.initializr.generator.project.ProjectAssetGenerator;
import io.spring.initializr.generator.project.ProjectDescription;
import io.spring.initializr.generator.project.ProjectGenerationContext;
import io.spring.initializr.generator.project.ProjectGenerationException;
import io.spring.initializr.generator.project.ProjectGenerator;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import io.spring.initializr.metadata.support.MetadataBuildItemResolver;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class ProjectGenerationInvokerCleanTempFilesTest {

	private ProjectGenerationInvoker<?> invoker;

	private Map<Path, List<Path>> temporaryFiles;

	@BeforeEach
	public void setup() {
		ApplicationContext parentApplicationContext = mock(ApplicationContext.class);
		ApplicationEventPublisher eventPublisher = mock(ApplicationEventPublisher.class);
		ProjectRequestToDescriptionConverter<?> requestConverter = mock(ProjectRequestToDescriptionConverter.class);

		invoker = new ProjectGenerationInvoker<>(parentApplicationContext, eventPublisher, requestConverter);
		temporaryFiles = invoker.getTemporaryFiles();
	}

	@Test
	@Tag("valid")
	public void cleanExistingTempFiles() {
		Path mockDir = Mockito.mock(Path.class);
		Path mockTempFile = Mockito.mock(Path.class);
		temporaryFiles.put(mockDir, Arrays.asList(mockTempFile, mockTempFile));

		invoker.cleanTempFiles(mockDir);

		assertFalse(temporaryFiles.containsKey(mockDir));
	}

	@Test
	@Tag("invalid")
	public void cleanNonExistentTempFiles() {
		Path mockDir = Mockito.mock(Path.class);
		invoker.cleanTempFiles(mockDir);
		assertEquals(0, temporaryFiles.size());
	}

	@Test
	@Tag("boundary")
	public void handleTempFileDeletingException() throws IOException {
		Path mockDir = Mockito.mock(Path.class);
		Path mockTempFile = Mockito.mock(Path.class);
		temporaryFiles.put(mockDir, Arrays.asList(mockTempFile, mockTempFile));
		Mockito.doThrow(new IOException()).when(FileSystemUtils.class);
		FileSystemUtils.deleteRecursively(mockTempFile);

		invoker.cleanTempFiles(mockDir);

		assertFalse(temporaryFiles.containsKey(mockDir));
	}

}