/*
 * Copyright 2012-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=hashCode_2acf58e102
ROOST_METHOD_SIG_HASH=hashCode_44411a81c8

"""
Scenario 1: Test the hashCode for Non-Null Properties

Details:
  TestName: testHashCodeForNonNullProperties
  Description: This test checks the function when both 'property' and 'internal' fields are not null.
Execution:
  Arrange: Create two instances of the VersionProperty with same 'property' and 'internal' fields.
  Act: Compute and store the hashcode of both instances.
  Assert: Check if the hashcodes are equal.
Validation:
  Since the 'property' and 'internal' fields of both the instances are identical, the hashCode method must return the same value. It tests the consistency of the hashCode method.

Scenario 2: Compare hashCode with Different 'property' fields

Details:
  TestName: testHashCodeForDifferentPropertyFields
  Description: This test checks the function when two instances with different 'property' fields are passed.
Execution:
  Arrange: Create two instances of the VersionProperty with different 'property' fields and same 'internal' field.
  Act: Compute and store the hashcode of both instances.
  Assert: Check if the hashcodes are not equal.
Validation:
  Since two different objects (as per equals method) should ideally have different hashcodes, the hashCode method must return different values for different 'property' field. This helps in ensuring good performance of hash collections.

Scenario 3: Compare hashCode with Different 'internal' fields

Details:
  TestName: testHashCodeForDifferentInternalFields
  Description: This test checks the function when two instances with different 'internal' fields are passed.
Execution:
  Arrange: Create two instances of the VersionProperty with same 'property' fields and different 'internal' field.
  Act: Compute and store the hashcode of both instances.
  Assert: Check if the hashcodes are not equal.
Validation:
  Just like scenario 2, since two different objects (as per equals method) should ideally have different hashcodes, the hashCode method must return different values for different 'internal' field. This test checks the sensitivity of the hashCode method towards 'internal' field.

Scenario 4: Test the consistency of the hashCode over time

Details:
  TestName: testHashCodeConsistencyOverTime
  Description: This test checks the consistency of hashcode over time for the same object.
Execution:
  Arrange: Create an instance of 'VersionProperty'.
  Act: Compute and store the hashcode at two different times.
  Assert: Check if the hashcodes computed at different times are equal.
Validation:
  A good hashCode method returns the same value consistently over multiple invocations as long as the object's internal state doesn't change. This consistency ensures a more robust and efficient usage in hash-based collections.

"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import java.util.Objects;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.*;
import java.io.Serializable;
import java.util.Arrays;
import java.util.List;
import org.springframework.util.StringUtils;

class VersionPropertyHashCodeTest {

	@Test
	@Tag("valid")
	void testHashCodeForNonNullProperties() {
		VersionProperty versionProp1 = VersionProperty.of("property", true);
		VersionProperty versionProp2 = VersionProperty.of("property", true);
		int hashCode1 = versionProp1.hashCode();
		int hashCode2 = versionProp2.hashCode();
		Assertions.assertEquals(hashCode1, hashCode2);
	}

	@Test
	@Tag("valid")
	void testHashCodeForDifferentPropertyFields() {
		VersionProperty versionProp1 = VersionProperty.of("property1", true);
		VersionProperty versionProp2 = VersionProperty.of("property2", true);
		int hashCode1 = versionProp1.hashCode();
		int hashCode2 = versionProp2.hashCode();
		Assertions.assertNotEquals(hashCode1, hashCode2);
	}

	@Test
	@Tag("valid")
	void testHashCodeForDifferentInternalFields() {
		VersionProperty versionProp1 = VersionProperty.of("property", true);
		VersionProperty versionProp2 = VersionProperty.of("property", false);
		int hashCode1 = versionProp1.hashCode();
		int hashCode2 = versionProp2.hashCode();
		Assertions.assertNotEquals(hashCode1, hashCode2);
	}

	@Test
	@Tag("valid")
	void testHashCodeConsistencyOverTime() {
		VersionProperty versionProp = VersionProperty.of("property", true);
		int hashCode1 = versionProp.hashCode();
		int hashCode2 = versionProp.hashCode();
		Assertions.assertEquals(hashCode1, hashCode2);
	}

}