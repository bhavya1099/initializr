/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=ofProperty_9a34666daa
ROOST_METHOD_SIG_HASH=ofProperty_66d224beda

"""
Scenario 1: Successfully creating a VersionReference instance through a valid internal property
TestName: testCreationViaValidInternalProperty
Description: This test aims to validate the successful creation of a VersionReference instance when a valid internal property is passed onto the method.
Execution:
  Arrange: A string of property needs to be created.
  Act: Invoke the ofProperty method with the created string property.
  Assert: Assert that the returned VersionReference instance is not null and isProperty method returns true.
Validation:
  The assertion checks if the method has successfully created a VersionReference instance. According to the business logic of VersionReference, the ofProperty method is intended to return a new VersionReference instance.

Scenario 2: Handling null internal property
TestName: testCreationWithNullInternalProperty
Description: This test is aimed to validate how the method handles a null input, a usual edge case.
Execution:
  Arrange: Set the internalProperty as null.
  Act: Invoke the ofProperty method with null as a parameter.
  Assert: Assert that the returned VersionReference instance is not null and isProperty method returns false.
Validation:
  The assertion verifies if the method can handle null cases. If a null input is provided, the method should still return a new VersionReference instance, but isProperty method would return false.

Scenario 3: Creating a VersionReference instance with a complex internal property
TestName: testCreationWithComplexInternalProperty
Description: This test is designed to check how the method responds to a complex internal property string.
Execution:
  Arrange: Define a string variable internalProperty with various special characters and numeric values.
  Act: Invoke the ofProperty method with the created string as an argument.
  Assert: Assert that the returned VersionReference instance is not null.
Validation:
  The assertion verifies the method's ability to handle complex cases. According to the business logic of VersionReference, the ofProperty method should be able to process any string value and return a new VersionReference instance.

Scenario 4: Using an internal property which already exists as a VersionProperty
TestName: testCreationWithExistingVersionProperty
Description: This test is aimed to verify that the method can handle cases where the input internalProperty has already been defined as a VersionProperty
Execution:
  Arrange: Define a string variable which already exists as a VersionProperty.
  Act: Call the ofProperty method with the predefined VersionProperty string as an argument.
  Assert: Assert that the returned VersionReference instance is not null and isProperty method returns true.
Validation:
  The assertion verifies if the method works correctly when a predefined VersionProperty is used. According to the business logic of VersionReference, the method should return a VersionReference instance even if the provided internalProperty string already exists as a VersionProperty.
"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.experimental.categories.Category;
import java.util.Objects;

public class VersionReferenceOfProperty817Test {

	@Test
	@Category(Categories.valid.class)
	public void testCreationViaValidInternalProperty() {
		// Arrange
		String property = "validProperty";
		// Act
		VersionReference result = VersionReference.ofProperty(property);
		// Assert
		assertNotNull(result, "Expected non-null VersionReference.");
		assertTrue(result.isProperty(), "Expected returned instance to represent a property.");
	}

	@Test
	@Category(Categories.boundary.class)
	public void testCreationWithNullInternalProperty() {
		// Arrange
		String property = null;
		// Act
		VersionReference result = VersionReference.ofProperty(property);
		// Assert
		assertNotNull(result, "Expected non-null VersionReference.");
		assertFalse(result.isProperty(), "Expected returned instance to represent a non-property value.");
	}

	@Test
	@Category(Categories.valid.class)
	public void testCreationWithComplexInternalProperty() {
		// Arrange
		String property = "50.#$@";
		// Act
		VersionReference result = VersionReference.ofProperty(property);
		// Assert
		assertNotNull(result, "Expected non-null VersionReference.");
	}

	@Test
	@Category(Categories.integration.class)
	public void testCreationWithExistingVersionProperty() {
		// Arrange
		String property = "existingProperty";
		VersionProperty versionProperty = mock(VersionProperty.class);
		when(versionProperty.of(property)).thenReturn(versionProperty);
		// Act
		VersionReference result = VersionReference.ofProperty(property);
		// Assert
		assertNotNull(result, "Expected non-null VersionReference.");
		assertTrue(result.isProperty(), "Expected returned instance to represent a property.");
		verify(versionProperty, times(1)).of(property);
	}

}