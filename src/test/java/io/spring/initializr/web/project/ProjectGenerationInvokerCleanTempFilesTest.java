/*
 * Copyright 2012-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=cleanTempFiles_c6aa981e2a
ROOST_METHOD_SIG_HASH=cleanTempFiles_d130d5e1bc

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/java-report-test/d854f7fc-c571-4395-a8d5-7c882b49aed8/source/initializr/initializr-web/src/test/java/io/spring/initializr/web/project/ProjectGenerationInvokerTests.java
Tests:
    "@Test
@Test
void cleanupTempFilesShouldOnlyCleanupSpecifiedDir() throws IOException {
    WebProjectRequest request = new WebProjectRequest();
    request.initialize(metadata);
    request.setType("gradle-project");
    ProjectGenerationResult result = this.invoker.invokeProjectStructureGeneration(request);
    this.invoker.cleanTempFiles(result.getRootDirectory());
    assertThat(result.getRootDirectory()).doesNotExist();
}
""""
Scenario 1: Test cleanTempFiles when directory is valid and contains temporary files.

  Details:
    TestName: testCleanTempFilesWithValidDirAndTempFiles.
    Description: The test is intended to verify the proper deletion of temporary files in a given directory path.
  Execution:
    Arrange: Create a valid directory Path object with mock temporary files. Add this directory to the map of temporaryFiles.
    Act: Invoke the method cleanTempFiles with this directory Path as the parameter.
    Assert: Check if the list of temporary files in the directory is now empty and the directory has been removed from the map of temporaryFiles.
  Validation:
    It verifies that the function correctly deletes all temporary files in a provided directory and also removes the directory from the map. This confirms the method’s ability to clean up temporary files within a valid directory.


Scenario 2: Test cleanTempFiles when directory is valid but contains no temporary files.

  Details:
    TestName: testCleanTempFilesWithEmptyDir.
    Description: The test intends to check if the cleanTempFiles method appropriately handles a directory with no temporary files.
  Execution:
    Arrange: Create a valid directory Path object with no temporary files. Add this directory to the map of temporaryFiles.
    Act: Call the method cleanTempFiles with this directory Path as the parameter.
    Assert: Confirm that the directory is no longer present in the map of temporaryFiles.
  Validation:
    This test affirms the method’s ability to correctly remove an empty directory from the temporaryFiles map.

Scenario 3: Test cleanTempFiles using an invalid directory path.

  Details:
    TestName: testCleanTempFilesWithInvalidDir.
    Description: The test strives to validate that the cleanTempFiles method correctly handles invalid directory paths.
  Execution:
    Arrange: Create an invalid directory Path object. The invalid directory should not be added to the temporaryFiles map.
    Act: Invoke the cleanTempFiles method, passing in the invalid directory Path.
    Assert: Verify that the size of the temporaryFiles map has not changed and no exceptions have been thrown.
  Validation:
    If the method can correctly handle invalid directory paths without throwing any exceptions and without affecting the temporaryFiles map, then it demonstrates its robustness within the program's error-handling processes.
"""
*/

// ********RoostGPT********

package io.spring.initializr.web.project;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.mockito.Mockito;
import org.junit.jupiter.api.*;
import java.io.IOException;
import java.io.StringWriter;
import io.spring.initializr.generator.buildsystem.BuildItemResolver;
import io.spring.initializr.generator.buildsystem.BuildWriter;
import io.spring.initializr.generator.project.DefaultProjectAssetGenerator;
import io.spring.initializr.generator.project.ProjectAssetGenerator;
import io.spring.initializr.generator.project.ProjectDescription;
import io.spring.initializr.generator.project.ProjectGenerationContext;
import io.spring.initializr.generator.project.ProjectGenerationException;
import io.spring.initializr.generator.project.ProjectGenerator;
import io.spring.initializr.metadata.InitializrMetadata;
import io.spring.initializr.metadata.InitializrMetadataProvider;
import io.spring.initializr.metadata.support.MetadataBuildItemResolver;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.util.FileSystemUtils;

public class ProjectGenerationInvokerCleanTempFilesTest {

	private ProjectGenerationInvoker projectGenerationInvoker;

	private Map<Path, List<Path>> temporaryFiles;

	@BeforeEach
	public void setUp() {
		this.temporaryFiles = new ConcurrentHashMap<>();
		this.projectGenerationInvoker = mock(ProjectGenerationInvoker.class, Mockito.CALLS_REAL_METHODS);
		when(projectGenerationInvoker.getTempFiles()).thenReturn(this.temporaryFiles);
	}

	@AfterEach
	public void tearDown() {
		this.projectGenerationInvoker = null;
		this.temporaryFiles.clear();
	}

	@Test
	@Tag("valid")
	public void testCleanTempFilesWithValidDirAndTempFiles() {
		// Arrange
		Path dir = Paths.get("/temp/dir");
		Path tempFile1 = Paths.get(dir + "/tempFile1.txt");
		Path tempFile2 = Paths.get(dir + "/tempFile2.txt");
		List<Path> tempFiles = new ArrayList<>();
		tempFiles.add(tempFile1);
		tempFiles.add(tempFile2);
		this.temporaryFiles.put(dir, tempFiles);
		assertEquals(1, this.temporaryFiles.size());
		// Act
		projectGenerationInvoker.cleanTempFiles(dir);
		// Assert
		assertTrue(this.temporaryFiles.isEmpty());
	}

	@Test
	@Tag("valid")
	public void testCleanTempFilesWithEmptyDir() {
		// Arrange
		Path dir = Paths.get("/temp/emptydir");
		this.temporaryFiles.put(dir, new ArrayList<>());
		assertEquals(1, this.temporaryFiles.size());
		// Act
		projectGenerationInvoker.cleanTempFiles(dir);
		// Assert
		assertTrue(this.temporaryFiles.isEmpty());
	}

	@Test
	@Tag("invalid")
	public void testCleanTempFilesWithInvalidDir() {
		// Arrange
		Path invalidDir = Paths.get("/invalid/dir");
		int mapSizeBeforeMethodCall = this.temporaryFiles.size();
		// Act
		projectGenerationInvoker.cleanTempFiles(invalidDir);
		// Assert
		assertEquals(mapSizeBeforeMethodCall, this.temporaryFiles.size());
	}

}