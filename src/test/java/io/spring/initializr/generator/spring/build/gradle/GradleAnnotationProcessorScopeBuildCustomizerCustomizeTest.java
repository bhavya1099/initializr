/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=customize_c8a43dcba1
ROOST_METHOD_SIG_HASH=customize_deb7e13fa6

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/java-report-test/1746075742/source/initializr/initializr-generator-spring/src/test/java/io/spring/initializr/generator/spring/build/gradle/GradleConfigurationBuildCustomizerTests.java
Tests:
    "@Test
private void customize(GradleBuild build) {
    new GradleConfigurationBuildCustomizer().customize(build);
}
"

File Path: /var/tmp/Roost/RoostGPT/java-report-test/1746075742/source/initializr/initializr-generator-spring/src/test/java/io/spring/initializr/generator/spring/build/gradle/GradleAnnotationProcessorScopeBuildCustomizerTests.java
Tests:
    "@Test
private void customize(GradleBuild build) {
    new GradleAnnotationProcessorScopeBuildCustomizer().customize(build);
}
"

File Path: /var/tmp/Roost/RoostGPT/java-report-test/1746075742/source/initializr/initializr-web/src/test/java/io/spring/initializr/web/project/MetadataProjectDescriptionCustomizerTests.java
Tests:
    "@Test
MutableProjectDescription customize(MutableProjectDescription description) {
    new MetadataProjectDescriptionCustomizer(this.metadata).customize(description);
    return description;
}
""""
  Scenario 1: Validate if 'customize' correctly changes configuration based on annotation processor dependency

  Details:
    TestName: checkCustomizeEffectOnAnnotations
    Description: This test is meant to check if the 'customize' method successfully modifies the Gradle configuration when dependencies of scope 'ANNOTATION_PROCESSOR' are present.
  Execution:
    Arrange: Mock a GradleBuild object containing at least one dependency of scope 'ANNOTATION_PROCESSOR'.
    Act: Invoke the 'customize' method with the set up GradleBuild object.
    Assert: Assert that the customize method has added a new configuration named "compileOnly" that extendsFrom "annotationProcessor".
  Validation:
    The assertion verifies that the 'customize' method works as expected when dependencies of scope 'ANNOTATION_PROCESSOR' are present. This is important as the correct configuration change ensures the project will compile with the annotation processor dependencies.

  Scenario 2: Validate if 'customize' does not change configuration when no annotation processor dependencies are present

  Details:
    TestName: checkCustomizeWithoutAnnotations
    Description: This test is meant to check if the 'customize' method does not have any effect when no dependencies of scope 'ANNOTATION_PROCESSOR' are present.
  Execution:
    Arrange: Mock a GradleBuild object without any dependency of scope 'ANNOTATION_PROCESSOR'.
    Act: Invoke the 'customize' method with the set up GradleBuild object.
    Assert: Assert that the customize method has not created a new configuration named "compileOnly".
  Validation:
    The assertion verifies that the 'customize' method correctly recognizes the absence of 'ANNOTATION_PROCESSOR' dependencies and does not modify the configuration. This is crucial for maintaining the integrity of the build configuration when such dependencies are not used.

  Scenario 3: Validate if 'customize' is idempotent and does not modify the configuration when already correctly set

  Details:
    TestName: checkCustomizeIsIdempotent
    Description: This test is meant to check if the 'customize' method doesn't change the Gradle configuration when invoked on a GradleBuild object that already has a correct "compileOnly" configuration.
  Execution:
    Arrange: Mock a GradleBuild object with a configuration named "compileOnly" that extendsFrom "annotationProcessor" and a dependency of scope 'ANNOTATION_PROCESSOR'.
    Act: Invoke the 'customize' method with the set up GradleBuild object.
    Assert: Assert that the customize method has not changed the existing "compileOnly" configuration.
  Validation:
    The assertion verifies that the 'customize' method does not make changes when they are not needed, providing evidence of its idempotency. This is important for maintaining the integrity of the build configuration when no changes are required.
"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.spring.build.gradle;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;
import io.spring.initializr.generator.buildsystem.Dependency;
import io.spring.initializr.generator.buildsystem.DependencyScope;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.*;
import io.spring.initializr.generator.buildsystem.gradle.GradleBuild;
import io.spring.initializr.generator.spring.build.BuildCustomizer;
import org.springframework.core.Ordered;

public class GradleAnnotationProcessorScopeBuildCustomizerCustomizeTest {

	@Test
	@Tag("valid")
	public void checkCustomizeEffectOnAnnotations() {
		GradleBuild gradleBuild = Mockito.mock(GradleBuild.class);
		List<Dependency> dependencies = new ArrayList<>();
		dependencies.add(new Dependency("group", "name", "version", DependencyScope.ANNOTATION_PROCESSOR));

		when(gradleBuild.dependencies().items()).thenReturn(dependencies);

		GradleAnnotationProcessorScopeBuildCustomizer gradleAnnotationProcessorScopeBuildCustomizer = new GradleAnnotationProcessorScopeBuildCustomizer();
		gradleAnnotationProcessorScopeBuildCustomizer.customize(gradleBuild);

		verify(gradleBuild.configurations(), times(1)).customize(eq("compileOnly"), any());
	}

	@Test
	@Tag("valid")
	public void checkCustomizeWithoutAnnotations() {
		GradleBuild gradleBuild = Mockito.mock(GradleBuild.class);
		List<Dependency> dependencies = new ArrayList<>();
		dependencies.add(new Dependency("group", "name", "version"));

		when(gradleBuild.dependencies().items()).thenReturn(dependencies);

		GradleAnnotationProcessorScopeBuildCustomizer gradleAnnotationProcessorScopeBuildCustomizer = new GradleAnnotationProcessorScopeBuildCustomizer();
		gradleAnnotationProcessorScopeBuildCustomizer.customize(gradleBuild);

		verify(gradleBuild.configurations(), times(0)).customize(eq("compileOnly"), any());
	}

	@Test
	@Tag("boundary")
	public void checkCustomizeIsIdempotent() {
		GradleBuild gradleBuild = Mockito.mock(GradleBuild.class);
		List<Dependency> dependencies = new ArrayList<>();
		dependencies.add(new Dependency("group", "name", "version", DependencyScope.ANNOTATION_PROCESSOR));

		when(gradleBuild.dependencies().items()).thenReturn(dependencies);

		GradleAnnotationProcessorScopeBuildCustomizer gradleAnnotationProcessorScopeBuildCustomizer = new GradleAnnotationProcessorScopeBuildCustomizer();
		gradleAnnotationProcessorScopeBuildCustomizer.customize(gradleBuild);
		gradleAnnotationProcessorScopeBuildCustomizer.customize(gradleBuild);

		verify(gradleBuild.configurations(), times(1)).customize(eq("compileOnly"), any());
	}

}