/*
 * Copyright 2012-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=springBootApplicationAnnotator_0b5eb46fcc
ROOST_METHOD_SIG_HASH=springBootApplicationAnnotator_d1065844ea

"""
Scenario 1: Validate if the springBootApplicationAnnotator method adds Spring Boot Application annotation to TypeDeclaration.

Details:
   TestName: testSpringBootApplicationAnnotatorMethod.
   Description: This test aims to verify that the method springBootApplicationAnnotator adds a Spring Boot Application annotation to TypeDeclaration.
Execution:
   Arrange: Mock a TypeDeclaration object.
   Act: Invoke the springBootApplicationAnnotator method and pass the mocked object.
   Assert: Verify that one annotation, ClassName.of("org.springframework.boot.autoconfigure.SpringBootApplication"), is returned.
Validation:
   This test case checks to validate if the Spring Boot Application annotation is added to the TypeDeclaration object.

Scenario 2: Validate springBootApplicationAnnotator Method with Null Parameter.

Details:
   TestName: testNullTypeDeclaration.
   Description: This test aims to verify that the method springBootApplicationAnnotator handles null TypeDeclaration properly.
Execution:
   Arrange: Pass null as a TypeDeclaration object.
   Act: Invoke the springBootApplicationAnnotator method.
   Assert: Verify that the method throws an appropriate exception.
Validation:
   This test case checks if the springBootApplicationAnnotator method can handle the null parameter, ensuring no exception or error is overlooked.

Scenario 3: Testing springBootApplicationAnnotator Method with Existing Annotations.

Details:
   TestName: testExistingAnnotations.
   Description: The test aims to verify that springBootApplicationAnnotator Method retains previous annotations and adds the Spring Boot Application annotation.
Execution:
   Arrange: Mock a TypeDeclaration object that has existing annotations.
   Act: Call the springBootApplicationAnnotator method and pass the mocked object.
   Assert: Ensure the previously existing annotations still exist and the new Spring Boot annotation has been added.
Validation:
   This test case aims to confirm that springBootApplicationAnnotator method maintains other annotations while adding the Spring Boot Application annotation, thus verifying its non-destructive behavior.

"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.spring.code;

import io.spring.initializr.generator.language.ClassName;
import io.spring.initializr.generator.language.TypeDeclaration;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import io.spring.initializr.generator.condition.ConditionalOnPackaging;
import io.spring.initializr.generator.condition.ConditionalOnPlatformVersion;
import io.spring.initializr.generator.packaging.war.WarPackaging;
import io.spring.initializr.generator.project.ProjectDescription;
import io.spring.initializr.generator.project.ProjectGenerationConfiguration;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

public class SourceCodeProjectGenerationConfigurationSpringBootApplicationAnnotatorTest {

	@Test
	@Tag("valid")
	public void testSpringBootApplicationAnnotatorMethod() {
		SourceCodeProjectGenerationConfiguration config = new SourceCodeProjectGenerationConfiguration();
		TypeDeclaration typeDeclaration = Mockito.mock(TypeDeclaration.class);
		config.springBootApplicationAnnotator().customize(typeDeclaration);
		Mockito.verify(typeDeclaration, Mockito.times(1))
			.annotations()
			.add(ClassName.of("org.springframework.boot.autoconfigure.SpringBootApplication"));
	}

	@Test
	@Tag("invalid")
	public void testNullTypeDeclaration() {
		SourceCodeProjectGenerationConfiguration config = new SourceCodeProjectGenerationConfiguration();
		assertThrows(NullPointerException.class, () -> config.springBootApplicationAnnotator().customize(null));
	}

	@Test
	@Tag("valid")
	public void testExistingAnnotations() {
		SourceCodeProjectGenerationConfiguration config = new SourceCodeProjectGenerationConfiguration();

		// Creating a mock TypeDeclaration with existing annotations
		TypeDeclaration typeDeclaration = Mockito.mock(TypeDeclaration.class);
		List<ClassName> existingAnnotations = new ArrayList<>();
		existingAnnotations.add(ClassName.of("org.springframework.stereotype.Component"));

		Mockito.when(typeDeclaration.annotations()).thenReturn(existingAnnotations);
		config.springBootApplicationAnnotator().customize(typeDeclaration);

		assertTrue(existingAnnotations.contains(ClassName.of("org.springframework.stereotype.Component")),
				"Existing annotations should be retained");
		assertTrue(
				existingAnnotations
					.contains(ClassName.of("org.springframework.boot.autoconfigure.SpringBootApplication")),
				"Spring Boot Application annotation should be added");
	}

}