/*
 * Copyright 2012-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=safeParse_e250bf95e0
ROOST_METHOD_SIG_HASH=safeParse_8f0434d7e5

"""
Scenario 1: Valid version string parse operation
Details:
  TestName: testParseValidVersionString
  Description: This scenario tests whether a valid version string can be correctly parsed without any errors. The purpose is to confirm that the function correctly returns a Version object when provided with a valid version string.
Execution:
  Arrange: Instantiate a valid version string such as  "1.2.3".
  Act: Invoke the target method safeParse using the valid version string as a parameter.
  Assert: Use JUnit assertions to compare the returned Version object against the expected Version, which can be created directly using Version class constructors.
Validation:
  The assertion aims to verify that the Version object returned by the safeParse method matches exactly with the expected Version instance. If the test passes, it confirms that the safeParse() method is functioning correctly for valid version strings.

Scenario 2: Null value handling
Details:
  TestName: testSafeParseWithNullInput
  Description: The scenario tests the exception handling capacity of the safeParse method, specifically when null is passed as the version string. The aim is to confirm that the method handles null inputs correctly, without interruption or error.
Execution:
  Arrange: No arrangement needed as the input will be null.
  Act: Invoke the target method safeParse with null as the argument.
  Assert: Assert that the return value of the method is null.
Validation:
  This test checks if the function can handle null values correctly without throwing an error. If the test passes, it confirms that safeParse() correctly handles null inputs by returning null, thus preventing possible NullPointException.

Scenario 3: Invalid version string error handling
Details:
  TestName: testParseInvalidVersionString
  Description: This scenario tests the safeParse method's ability to handle invalid version strings, such as text that does not represent a valid software version (e.g., "foo").
Execution:
  Arrange: Instantiate an invalid version string, such as "foo".
  Act: Invoke the target method safeParse using the invalid string as a parameter.
  Assert: Assert that the return value of the method is null.
Validation:
  The assertion verifies if the method correctly returns null when given an invalid version string, as per the documented behavior. If the test passes, it confirms that safeParse handles invalid inputs gracefully without throwing an error.

Scenario 4: Exception handling
Details:
  TestName: testSafeParseExceptionHandling
  Description: This test aims to verify that the method safeParse correctly catches the InvalidVersionException thrown by the parse method and returns null as expected.
Execution:
  Arrange: Mock the parse() method to throw an InvalidVersionException when called.
  Act: Invoke the safeParse() method.
  Assert: Assert that the returned value is null.
Validation:
  The assertion ensures that the safeParse() method correctly catches the thrown exception and returns null. If the safeParse() method does not handle the exception, the test will fail, indicating a problem with the exception handling in the method.
"""
*/

// ********RoostGPT********

package io.spring.initializr.generator.version;

import java.util.stream.Stream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.function.Function;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

public class VersionSafeParseTest {

	private static final String VALID_VERSION = "1.2.3";

	private static final String INVALID_VERSION = "foo";

	private Version versionMock;

	@BeforeEach
	public void setup() {
		versionMock = mock(Version.class);
	}

	@Test
    @Tag("valid")
    public void testParseValidVersionString() {
        when(versionMock.parse(VALID_VERSION)).thenReturn(new Version(1, 2, 3, new Version.Qualifier("1.2.3", 1, ".")));
        Version result = Version.safeParse(VALID_VERSION);
        assertNotNull(result);
        assertEquals(new Version(1, 2, 3, new Version.Qualifier("1.2.3", 1, ".")), result);
    }

	@Test
	@Tag("invalid")
	public void testSafeParseWithNullInput() {
		Version result = Version.safeParse(null);
		assertNull(result);
	}

	@Test
    @Tag("invalid")
    public void testParseInvalidVersionString() {
        when(versionMock.parse(INVALID_VERSION)).thenThrow(InvalidVersionException.class);
        Version result = Version.safeParse(INVALID_VERSION);
        assertNull(result);
    }

	@Test
    @Tag("boundary")
    public void testSafeParseExceptionHandling() {
        when(versionMock.parse(anyString())).thenThrow(InvalidVersionException.class);
        Version result = Version.safeParse("1.2.3");
        assertNull(result);
    }

}